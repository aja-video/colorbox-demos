/**
 * OpenAPI ColorBox
 * This is a REST API for the AJA ColorBox product.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@aja.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 *       Do not edit the class manually.
 *
 * Copyright (C) 2020-2022 AJA Video Systems Inc.  All rights reserved.
 */

#include "OAIDefaultApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIDefaultApi::OAIDefaultApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIDefaultApi::~OAIDefaultApi() {
}

void OAIDefaultApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("/v2"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("get1dLutLibrary", defaultConf);
    _serverIndices.insert("get1dLutLibrary", 0);
    _serverConfigs.insert("get3dLutLibrary", defaultConf);
    _serverIndices.insert("get3dLutLibrary", 0);
    _serverConfigs.insert("getActiveParamsForGivenNetDeviceIndex", defaultConf);
    _serverIndices.insert("getActiveParamsForGivenNetDeviceIndex", 0);
    _serverConfigs.insert("getAllNetDevices", defaultConf);
    _serverIndices.insert("getAllNetDevices", 0);
    _serverConfigs.insert("getAllStatus", defaultConf);
    _serverIndices.insert("getAllStatus", 0);
    _serverConfigs.insert("getAllSystemDiscovers", defaultConf);
    _serverIndices.insert("getAllSystemDiscovers", 0);
    _serverConfigs.insert("getAncCaptureFilter", defaultConf);
    _serverIndices.insert("getAncCaptureFilter", 0);
    _serverConfigs.insert("getBbcConfig", defaultConf);
    _serverIndices.insert("getBbcConfig", 0);
    _serverConfigs.insert("getCalibrationPattern", defaultConf);
    _serverIndices.insert("getCalibrationPattern", 0);
    _serverConfigs.insert("getColorfrontConfig", defaultConf);
    _serverIndices.insert("getColorfrontConfig", 0);
    _serverConfigs.insert("getConfigForGivenNetDeviceIndex", defaultConf);
    _serverIndices.insert("getConfigForGivenNetDeviceIndex", 0);
    _serverConfigs.insert("getFrameStore", defaultConf);
    _serverIndices.insert("getFrameStore", 0);
    _serverConfigs.insert("getImageLibrary", defaultConf);
    _serverIndices.insert("getImageLibrary", 0);
    _serverConfigs.insert("getLibraryControl", defaultConf);
    _serverIndices.insert("getLibraryControl", 0);
    _serverConfigs.insert("getMatrixLibrary", defaultConf);
    _serverIndices.insert("getMatrixLibrary", 0);
    _serverConfigs.insert("getNbcConfig", defaultConf);
    _serverIndices.insert("getNbcConfig", 0);
    _serverConfigs.insert("getOrionConfig", defaultConf);
    _serverIndices.insert("getOrionConfig", 0);
    _serverConfigs.insert("getOutputConfig", defaultConf);
    _serverIndices.insert("getOutputConfig", 0);
    _serverConfigs.insert("getOutputStatus", defaultConf);
    _serverIndices.insert("getOutputStatus", 0);
    _serverConfigs.insert("getOverlay", defaultConf);
    _serverIndices.insert("getOverlay", 0);
    _serverConfigs.insert("getPipelineStages", defaultConf);
    _serverIndices.insert("getPipelineStages", 0);
    _serverConfigs.insert("getPreviewImage", defaultConf);
    _serverIndices.insert("getPreviewImage", 0);
    _serverConfigs.insert("getRouting", defaultConf);
    _serverIndices.insert("getRouting", 0);
    _serverConfigs.insert("getSdiInputConfig", defaultConf);
    _serverIndices.insert("getSdiInputConfig", 0);
    _serverConfigs.insert("getSdiInputStatus", defaultConf);
    _serverIndices.insert("getSdiInputStatus", 0);
    _serverConfigs.insert("getStagedParamsForGivenNetDeviceIndex", defaultConf);
    _serverIndices.insert("getStagedParamsForGivenNetDeviceIndex", 0);
    _serverConfigs.insert("getStatusForGivenNetDeviceIndex", defaultConf);
    _serverIndices.insert("getStatusForGivenNetDeviceIndex", 0);
    _serverConfigs.insert("getSystemConfig", defaultConf);
    _serverIndices.insert("getSystemConfig", 0);
    _serverConfigs.insert("getSystemPresetLibrary", defaultConf);
    _serverIndices.insert("getSystemPresetLibrary", 0);
    _serverConfigs.insert("getSystemStatus", defaultConf);
    _serverIndices.insert("getSystemStatus", 0);
    _serverConfigs.insert("getWiFiConfig", defaultConf);
    _serverIndices.insert("getWiFiConfig", 0);
    _serverConfigs.insert("getWiFiStatus", defaultConf);
    _serverIndices.insert("getWiFiStatus", 0);
    _serverConfigs.insert("setActiveParamsForGivenNetDeviceIndex", defaultConf);
    _serverIndices.insert("setActiveParamsForGivenNetDeviceIndex", 0);
    _serverConfigs.insert("setAllStatus", defaultConf);
    _serverIndices.insert("setAllStatus", 0);
    _serverConfigs.insert("setAllSystemDiscovers", defaultConf);
    _serverIndices.insert("setAllSystemDiscovers", 0);
    _serverConfigs.insert("setAncCaptureFilter", defaultConf);
    _serverIndices.insert("setAncCaptureFilter", 0);
    _serverConfigs.insert("setBbcConfig", defaultConf);
    _serverIndices.insert("setBbcConfig", 0);
    _serverConfigs.insert("setCalibrationPattern", defaultConf);
    _serverIndices.insert("setCalibrationPattern", 0);
    _serverConfigs.insert("setColorfrontConfig", defaultConf);
    _serverIndices.insert("setColorfrontConfig", 0);
    _serverConfigs.insert("setConfigForGivenNetDeviceIndex", defaultConf);
    _serverIndices.insert("setConfigForGivenNetDeviceIndex", 0);
    _serverConfigs.insert("setFrameStore", defaultConf);
    _serverIndices.insert("setFrameStore", 0);
    _serverConfigs.insert("setLibraryControl", defaultConf);
    _serverIndices.insert("setLibraryControl", 0);
    _serverConfigs.insert("setLicenseGenerationRequest", defaultConf);
    _serverIndices.insert("setLicenseGenerationRequest", 0);
    _serverConfigs.insert("setNbcConfig", defaultConf);
    _serverIndices.insert("setNbcConfig", 0);
    _serverConfigs.insert("setOrionConfig", defaultConf);
    _serverIndices.insert("setOrionConfig", 0);
    _serverConfigs.insert("setOutputConfig", defaultConf);
    _serverIndices.insert("setOutputConfig", 0);
    _serverConfigs.insert("setOutputStatus", defaultConf);
    _serverIndices.insert("setOutputStatus", 0);
    _serverConfigs.insert("setOverlay", defaultConf);
    _serverIndices.insert("setOverlay", 0);
    _serverConfigs.insert("setPipelineStages", defaultConf);
    _serverIndices.insert("setPipelineStages", 0);
    _serverConfigs.insert("setPreviewImage", defaultConf);
    _serverIndices.insert("setPreviewImage", 0);
    _serverConfigs.insert("setRouting", defaultConf);
    _serverIndices.insert("setRouting", 0);
    _serverConfigs.insert("setSdiInputConfig", defaultConf);
    _serverIndices.insert("setSdiInputConfig", 0);
    _serverConfigs.insert("setSdiInputStatus", defaultConf);
    _serverIndices.insert("setSdiInputStatus", 0);
    _serverConfigs.insert("setStagedParamsForGivenNetDeviceIndex", defaultConf);
    _serverIndices.insert("setStagedParamsForGivenNetDeviceIndex", 0);
    _serverConfigs.insert("setStatusForGivenNetDeviceIndex", defaultConf);
    _serverIndices.insert("setStatusForGivenNetDeviceIndex", 0);
    _serverConfigs.insert("setSystemConfig", defaultConf);
    _serverIndices.insert("setSystemConfig", 0);
    _serverConfigs.insert("setSystemPassword", defaultConf);
    _serverIndices.insert("setSystemPassword", 0);
    _serverConfigs.insert("setSystemStatus", defaultConf);
    _serverIndices.insert("setSystemStatus", 0);
    _serverConfigs.insert("setWiFiConfig", defaultConf);
    _serverIndices.insert("setWiFiConfig", 0);
    _serverConfigs.insert("setWiFiStatus", defaultConf);
    _serverIndices.insert("setWiFiStatus", 0);
    _serverConfigs.insert("uploadFile", defaultConf);
    _serverIndices.insert("uploadFile", 0);
}

void OAIDefaultApi::setUrlForServers(const QString &host, int port, const QString &protocol, const QString &endPoint)
{
    QString url;
    if (port == -1)
        url = QString("%1://%2%3").arg(protocol).arg(host).arg(endPoint);
    else
        url = QString("%1://%2:%3%4").arg(protocol).arg(host).arg(port).arg(endPoint);
    for (auto &key : _serverConfigs.keys()) {
        for (auto &configs : _serverConfigs.values()) {
            for (auto &c : configs) {
                c._url = url;
            }
            _serverConfigs.insert(key, configs);
        }
    }
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIDefaultApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIDefaultApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIDefaultApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName,apiKey);
}

void OAIDefaultApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIDefaultApi::setUsername(const QString &username) {
    _username = username;
}

void OAIDefaultApi::setPassword(const QString &password) {
    _password = password;
}

void OAIDefaultApi::useBasicAuth(const QString &username, const QString &password) {
	if (!username.isEmpty()) { setUsername(username); }
	if (!password.isEmpty()) { setPassword(password); }

	QString nameAndPass = QString("%1:%2").arg(_username, _password);
	QString val = QString("Basic ") + nameAndPass.toUtf8().toBase64();
	addHeaders("Authorization", val);
}

void OAIDefaultApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIDefaultApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIDefaultApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIDefaultApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDefaultApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
#if QT_VERSION >= QT_VERSION_CHECK(5, 12, 0)
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
#else
    for (auto &e : _serverIndices.keys()) {
        setServerIndex(e, addServerConfiguration(e, url, description, variables));
    }
#endif
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDefaultApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIDefaultApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIDefaultApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIDefaultApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIDefaultApi::abortRequests() {
    emit abortRequestsSignal();
}

QString OAIDefaultApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIDefaultApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIDefaultApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIDefaultApi::get1dLutLibrary() {
    QString fullPath = QString(_serverConfigs["get1dLutLibrary"][_serverIndices.value("get1dLutLibrary")].URL()+"/1dLutLibrary");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::get1dLutLibraryCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::get1dLutLibraryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILibraryEntry> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAILibraryEntry val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit get1dLutLibrarySignal(output);
        emit get1dLutLibrarySignalFull(worker, output);
    } else {
        emit get1dLutLibrarySignalE(output, error_type, error_str);
        emit get1dLutLibrarySignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::get3dLutLibrary() {
    QString fullPath = QString(_serverConfigs["get3dLutLibrary"][_serverIndices.value("get3dLutLibrary")].URL()+"/3dLutLibrary");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::get3dLutLibraryCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::get3dLutLibraryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILibraryEntry> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAILibraryEntry val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit get3dLutLibrarySignal(output);
        emit get3dLutLibrarySignalFull(worker, output);
    } else {
        emit get3dLutLibrarySignalE(output, error_type, error_str);
        emit get3dLutLibrarySignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getActiveParamsForGivenNetDeviceIndex(const qint32 &dev_idx) {
    QString fullPath = QString(_serverConfigs["getActiveParamsForGivenNetDeviceIndex"][_serverIndices.value("getActiveParamsForGivenNetDeviceIndex")].URL()+"/net/device/{devIdx}/activeParams");
    
    
    {
        QString dev_idxPathParam("{");
        dev_idxPathParam.append("devIdx").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "devIdx", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"devIdx"+pathSuffix : pathPrefix;
        fullPath.replace(dev_idxPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dev_idx)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getActiveParamsForGivenNetDeviceIndexCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getActiveParamsForGivenNetDeviceIndexCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINetParams output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getActiveParamsForGivenNetDeviceIndexSignal(output);
        emit getActiveParamsForGivenNetDeviceIndexSignalFull(worker, output);
    } else {
        emit getActiveParamsForGivenNetDeviceIndexSignalE(output, error_type, error_str);
        emit getActiveParamsForGivenNetDeviceIndexSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getAllNetDevices() {
    QString fullPath = QString(_serverConfigs["getAllNetDevices"][_serverIndices.value("getAllNetDevices")].URL()+"/net/devices");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getAllNetDevicesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getAllNetDevicesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINetDevice> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAINetDevice val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getAllNetDevicesSignal(output);
        emit getAllNetDevicesSignalFull(worker, output);
    } else {
        emit getAllNetDevicesSignalE(output, error_type, error_str);
        emit getAllNetDevicesSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getAllStatus() {
    QString fullPath = QString(_serverConfigs["getAllStatus"][_serverIndices.value("getAllStatus")].URL()+"/status");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getAllStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getAllStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getAllStatusSignal(output);
        emit getAllStatusSignalFull(worker, output);
    } else {
        emit getAllStatusSignalE(output, error_type, error_str);
        emit getAllStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getAllSystemDiscovers() {
    QString fullPath = QString(_serverConfigs["getAllSystemDiscovers"][_serverIndices.value("getAllSystemDiscovers")].URL()+"/discovers");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getAllSystemDiscoversCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getAllSystemDiscoversCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAISystemDiscover> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAISystemDiscover val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getAllSystemDiscoversSignal(output);
        emit getAllSystemDiscoversSignalFull(worker, output);
    } else {
        emit getAllSystemDiscoversSignalE(output, error_type, error_str);
        emit getAllSystemDiscoversSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getAncCaptureFilter() {
    QString fullPath = QString(_serverConfigs["getAncCaptureFilter"][_serverIndices.value("getAncCaptureFilter")].URL()+"/ancCaptureFilter");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getAncCaptureFilterCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getAncCaptureFilterCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAncCaptureFilter output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getAncCaptureFilterSignal(output);
        emit getAncCaptureFilterSignalFull(worker, output);
    } else {
        emit getAncCaptureFilterSignalE(output, error_type, error_str);
        emit getAncCaptureFilterSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getBbcConfig() {
    QString fullPath = QString(_serverConfigs["getBbcConfig"][_serverIndices.value("getBbcConfig")].URL()+"/bbcConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getBbcConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getBbcConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBbcConfig output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getBbcConfigSignal(output);
        emit getBbcConfigSignalFull(worker, output);
    } else {
        emit getBbcConfigSignalE(output, error_type, error_str);
        emit getBbcConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getCalibrationPattern() {
    QString fullPath = QString(_serverConfigs["getCalibrationPattern"][_serverIndices.value("getCalibrationPattern")].URL()+"/calibrationPattern");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getCalibrationPatternCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getCalibrationPatternCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICalibrationPattern output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getCalibrationPatternSignal(output);
        emit getCalibrationPatternSignalFull(worker, output);
    } else {
        emit getCalibrationPatternSignalE(output, error_type, error_str);
        emit getCalibrationPatternSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getColorfrontConfig() {
    QString fullPath = QString(_serverConfigs["getColorfrontConfig"][_serverIndices.value("getColorfrontConfig")].URL()+"/colorfrontConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getColorfrontConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getColorfrontConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIColorfrontConfig output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getColorfrontConfigSignal(output);
        emit getColorfrontConfigSignalFull(worker, output);
    } else {
        emit getColorfrontConfigSignalE(output, error_type, error_str);
        emit getColorfrontConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getConfigForGivenNetDeviceIndex(const qint32 &dev_idx) {
    QString fullPath = QString(_serverConfigs["getConfigForGivenNetDeviceIndex"][_serverIndices.value("getConfigForGivenNetDeviceIndex")].URL()+"/net/device/{devIdx}/config");
    
    
    {
        QString dev_idxPathParam("{");
        dev_idxPathParam.append("devIdx").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "devIdx", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"devIdx"+pathSuffix : pathPrefix;
        fullPath.replace(dev_idxPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dev_idx)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getConfigForGivenNetDeviceIndexCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getConfigForGivenNetDeviceIndexCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINetConfig output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getConfigForGivenNetDeviceIndexSignal(output);
        emit getConfigForGivenNetDeviceIndexSignalFull(worker, output);
    } else {
        emit getConfigForGivenNetDeviceIndexSignalE(output, error_type, error_str);
        emit getConfigForGivenNetDeviceIndexSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getFrameStore() {
    QString fullPath = QString(_serverConfigs["getFrameStore"][_serverIndices.value("getFrameStore")].URL()+"/frameStore");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getFrameStoreCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getFrameStoreCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIFrameStore output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getFrameStoreSignal(output);
        emit getFrameStoreSignalFull(worker, output);
    } else {
        emit getFrameStoreSignalE(output, error_type, error_str);
        emit getFrameStoreSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getImageLibrary() {
    QString fullPath = QString(_serverConfigs["getImageLibrary"][_serverIndices.value("getImageLibrary")].URL()+"/imageLibrary");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getImageLibraryCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getImageLibraryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILibraryEntry> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAILibraryEntry val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getImageLibrarySignal(output);
        emit getImageLibrarySignalFull(worker, output);
    } else {
        emit getImageLibrarySignalE(output, error_type, error_str);
        emit getImageLibrarySignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getLibraryControl() {
    QString fullPath = QString(_serverConfigs["getLibraryControl"][_serverIndices.value("getLibraryControl")].URL()+"/libraryControl");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getLibraryControlCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getLibraryControlCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILibraryControl output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getLibraryControlSignal(output);
        emit getLibraryControlSignalFull(worker, output);
    } else {
        emit getLibraryControlSignalE(output, error_type, error_str);
        emit getLibraryControlSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getMatrixLibrary() {
    QString fullPath = QString(_serverConfigs["getMatrixLibrary"][_serverIndices.value("getMatrixLibrary")].URL()+"/matrixLibrary");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMatrixLibraryCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getMatrixLibraryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILibraryEntry> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAILibraryEntry val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMatrixLibrarySignal(output);
        emit getMatrixLibrarySignalFull(worker, output);
    } else {
        emit getMatrixLibrarySignalE(output, error_type, error_str);
        emit getMatrixLibrarySignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getNbcConfig() {
    QString fullPath = QString(_serverConfigs["getNbcConfig"][_serverIndices.value("getNbcConfig")].URL()+"/nbcConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getNbcConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getNbcConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINbcConfig output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getNbcConfigSignal(output);
        emit getNbcConfigSignalFull(worker, output);
    } else {
        emit getNbcConfigSignalE(output, error_type, error_str);
        emit getNbcConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getOrionConfig() {
    QString fullPath = QString(_serverConfigs["getOrionConfig"][_serverIndices.value("getOrionConfig")].URL()+"/orionConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getOrionConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getOrionConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOrionConfig output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getOrionConfigSignal(output);
        emit getOrionConfigSignalFull(worker, output);
    } else {
        emit getOrionConfigSignalE(output, error_type, error_str);
        emit getOrionConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getOutputConfig() {
    QString fullPath = QString(_serverConfigs["getOutputConfig"][_serverIndices.value("getOutputConfig")].URL()+"/outputConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getOutputConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getOutputConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOutputConfig output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getOutputConfigSignal(output);
        emit getOutputConfigSignalFull(worker, output);
    } else {
        emit getOutputConfigSignalE(output, error_type, error_str);
        emit getOutputConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getOutputStatus() {
    QString fullPath = QString(_serverConfigs["getOutputStatus"][_serverIndices.value("getOutputStatus")].URL()+"/outputStatus");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getOutputStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getOutputStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOutputConfig output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getOutputStatusSignal(output);
        emit getOutputStatusSignalFull(worker, output);
    } else {
        emit getOutputStatusSignalE(output, error_type, error_str);
        emit getOutputStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getOverlay() {
    QString fullPath = QString(_serverConfigs["getOverlay"][_serverIndices.value("getOverlay")].URL()+"/overlay");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getOverlayCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getOverlayCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOverlay output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getOverlaySignal(output);
        emit getOverlaySignalFull(worker, output);
    } else {
        emit getOverlaySignalE(output, error_type, error_str);
        emit getOverlaySignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getPipelineStages() {
    QString fullPath = QString(_serverConfigs["getPipelineStages"][_serverIndices.value("getPipelineStages")].URL()+"/pipelineStages");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getPipelineStagesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getPipelineStagesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPipelineStages output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineStagesSignal(output);
        emit getPipelineStagesSignalFull(worker, output);
    } else {
        emit getPipelineStagesSignalE(output, error_type, error_str);
        emit getPipelineStagesSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getPreviewImage() {
    QString fullPath = QString(_serverConfigs["getPreviewImage"][_serverIndices.value("getPreviewImage")].URL()+"/preview");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getPreviewImageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getPreviewImageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPreview output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPreviewImageSignal(output);
        emit getPreviewImageSignalFull(worker, output);
    } else {
        emit getPreviewImageSignalE(output, error_type, error_str);
        emit getPreviewImageSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getRouting() {
    QString fullPath = QString(_serverConfigs["getRouting"][_serverIndices.value("getRouting")].URL()+"/routing");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getRoutingCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getRoutingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIRouting output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getRoutingSignal(output);
        emit getRoutingSignalFull(worker, output);
    } else {
        emit getRoutingSignalE(output, error_type, error_str);
        emit getRoutingSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getSdiInputConfig() {
    QString fullPath = QString(_serverConfigs["getSdiInputConfig"][_serverIndices.value("getSdiInputConfig")].URL()+"/sdiInputConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getSdiInputConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getSdiInputConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISDI output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSdiInputConfigSignal(output);
        emit getSdiInputConfigSignalFull(worker, output);
    } else {
        emit getSdiInputConfigSignalE(output, error_type, error_str);
        emit getSdiInputConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getSdiInputStatus() {
    QString fullPath = QString(_serverConfigs["getSdiInputStatus"][_serverIndices.value("getSdiInputStatus")].URL()+"/sdiInputStatus");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getSdiInputStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getSdiInputStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISDI output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSdiInputStatusSignal(output);
        emit getSdiInputStatusSignalFull(worker, output);
    } else {
        emit getSdiInputStatusSignalE(output, error_type, error_str);
        emit getSdiInputStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getStagedParamsForGivenNetDeviceIndex(const qint32 &dev_idx) {
    QString fullPath = QString(_serverConfigs["getStagedParamsForGivenNetDeviceIndex"][_serverIndices.value("getStagedParamsForGivenNetDeviceIndex")].URL()+"/net/device/{devIdx}/stagedParams");
    
    
    {
        QString dev_idxPathParam("{");
        dev_idxPathParam.append("devIdx").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "devIdx", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"devIdx"+pathSuffix : pathPrefix;
        fullPath.replace(dev_idxPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dev_idx)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getStagedParamsForGivenNetDeviceIndexCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getStagedParamsForGivenNetDeviceIndexCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINetParams output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getStagedParamsForGivenNetDeviceIndexSignal(output);
        emit getStagedParamsForGivenNetDeviceIndexSignalFull(worker, output);
    } else {
        emit getStagedParamsForGivenNetDeviceIndexSignalE(output, error_type, error_str);
        emit getStagedParamsForGivenNetDeviceIndexSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getStatusForGivenNetDeviceIndex(const qint32 &dev_idx) {
    QString fullPath = QString(_serverConfigs["getStatusForGivenNetDeviceIndex"][_serverIndices.value("getStatusForGivenNetDeviceIndex")].URL()+"/net/device/{devIdx}/status");
    
    
    {
        QString dev_idxPathParam("{");
        dev_idxPathParam.append("devIdx").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "devIdx", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"devIdx"+pathSuffix : pathPrefix;
        fullPath.replace(dev_idxPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dev_idx)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getStatusForGivenNetDeviceIndexCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getStatusForGivenNetDeviceIndexCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINetStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getStatusForGivenNetDeviceIndexSignal(output);
        emit getStatusForGivenNetDeviceIndexSignalFull(worker, output);
    } else {
        emit getStatusForGivenNetDeviceIndexSignalE(output, error_type, error_str);
        emit getStatusForGivenNetDeviceIndexSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getSystemConfig() {
    QString fullPath = QString(_serverConfigs["getSystemConfig"][_serverIndices.value("getSystemConfig")].URL()+"/system/config");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getSystemConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getSystemConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISystemConfig output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSystemConfigSignal(output);
        emit getSystemConfigSignalFull(worker, output);
    } else {
        emit getSystemConfigSignalE(output, error_type, error_str);
        emit getSystemConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getSystemPresetLibrary() {
    QString fullPath = QString(_serverConfigs["getSystemPresetLibrary"][_serverIndices.value("getSystemPresetLibrary")].URL()+"/systemPresetLibrary");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getSystemPresetLibraryCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getSystemPresetLibraryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILibraryEntry> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach (QJsonValue obj, jsonArray) {
        OAILibraryEntry val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSystemPresetLibrarySignal(output);
        emit getSystemPresetLibrarySignalFull(worker, output);
    } else {
        emit getSystemPresetLibrarySignalE(output, error_type, error_str);
        emit getSystemPresetLibrarySignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getSystemStatus() {
    QString fullPath = QString(_serverConfigs["getSystemStatus"][_serverIndices.value("getSystemStatus")].URL()+"/system/status");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getSystemStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getSystemStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISystemStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSystemStatusSignal(output);
        emit getSystemStatusSignalFull(worker, output);
    } else {
        emit getSystemStatusSignalE(output, error_type, error_str);
        emit getSystemStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getWiFiConfig() {
    QString fullPath = QString(_serverConfigs["getWiFiConfig"][_serverIndices.value("getWiFiConfig")].URL()+"/wifiConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getWiFiConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getWiFiConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWiFiDeviceConfig output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getWiFiConfigSignal(output);
        emit getWiFiConfigSignalFull(worker, output);
    } else {
        emit getWiFiConfigSignalE(output, error_type, error_str);
        emit getWiFiConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getWiFiStatus() {
    QString fullPath = QString(_serverConfigs["getWiFiStatus"][_serverIndices.value("getWiFiStatus")].URL()+"/wifiStatus");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getWiFiStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getWiFiStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWiFiDeviceStatus output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getWiFiStatusSignal(output);
        emit getWiFiStatusSignalFull(worker, output);
    } else {
        emit getWiFiStatusSignalE(output, error_type, error_str);
        emit getWiFiStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setActiveParamsForGivenNetDeviceIndex(const qint32 &dev_idx, const OAINetParams &oai_net_params) {
    QString fullPath = QString(_serverConfigs["setActiveParamsForGivenNetDeviceIndex"][_serverIndices.value("setActiveParamsForGivenNetDeviceIndex")].URL()+"/net/device/{devIdx}/activeParams");
    
    if (_apiKeys.contains("app_id")) {
        addHeaders("app_id",_apiKeys.find("app_id").value());
    }
    
    
    {
        QString dev_idxPathParam("{");
        dev_idxPathParam.append("devIdx").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "devIdx", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"devIdx"+pathSuffix : pathPrefix;
        fullPath.replace(dev_idxPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dev_idx)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_net_params.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setActiveParamsForGivenNetDeviceIndexCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setActiveParamsForGivenNetDeviceIndexCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setActiveParamsForGivenNetDeviceIndexSignal();
        emit setActiveParamsForGivenNetDeviceIndexSignalFull(worker);
    } else {
        emit setActiveParamsForGivenNetDeviceIndexSignalE(error_type, error_str);
        emit setActiveParamsForGivenNetDeviceIndexSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setAllStatus(const OAIStatus &oai_status) {
    QString fullPath = QString(_serverConfigs["setAllStatus"][_serverIndices.value("setAllStatus")].URL()+"/status");
    
    if (_apiKeys.contains("app_id")) {
        addHeaders("app_id",_apiKeys.find("app_id").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_status.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setAllStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setAllStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setAllStatusSignal();
        emit setAllStatusSignalFull(worker);
    } else {
        emit setAllStatusSignalE(error_type, error_str);
        emit setAllStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setAllSystemDiscovers(const QList<OAISystemDiscover> &oai_system_discover) {
    QString fullPath = QString(_serverConfigs["setAllSystemDiscovers"][_serverIndices.value("setAllSystemDiscovers")].URL()+"/discovers");
    
    if (_apiKeys.contains("app_id")) {
        addHeaders("app_id",_apiKeys.find("app_id").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {
        QJsonDocument doc(::OpenAPI::toJsonValue(oai_system_discover).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setAllSystemDiscoversCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setAllSystemDiscoversCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setAllSystemDiscoversSignal();
        emit setAllSystemDiscoversSignalFull(worker);
    } else {
        emit setAllSystemDiscoversSignalE(error_type, error_str);
        emit setAllSystemDiscoversSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setAncCaptureFilter(const OAIAncCaptureFilter &oai_anc_capture_filter) {
    QString fullPath = QString(_serverConfigs["setAncCaptureFilter"][_serverIndices.value("setAncCaptureFilter")].URL()+"/ancCaptureFilter");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_anc_capture_filter.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setAncCaptureFilterCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setAncCaptureFilterCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setAncCaptureFilterSignal();
        emit setAncCaptureFilterSignalFull(worker);
    } else {
        emit setAncCaptureFilterSignalE(error_type, error_str);
        emit setAncCaptureFilterSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setBbcConfig(const OAIBbcConfig &oai_bbc_config) {
    QString fullPath = QString(_serverConfigs["setBbcConfig"][_serverIndices.value("setBbcConfig")].URL()+"/bbcConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_bbc_config.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setBbcConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setBbcConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setBbcConfigSignal();
        emit setBbcConfigSignalFull(worker);
    } else {
        emit setBbcConfigSignalE(error_type, error_str);
        emit setBbcConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setCalibrationPattern(const OAICalibrationPattern &oai_calibration_pattern) {
    QString fullPath = QString(_serverConfigs["setCalibrationPattern"][_serverIndices.value("setCalibrationPattern")].URL()+"/calibrationPattern");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_calibration_pattern.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setCalibrationPatternCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setCalibrationPatternCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setCalibrationPatternSignal();
        emit setCalibrationPatternSignalFull(worker);
    } else {
        emit setCalibrationPatternSignalE(error_type, error_str);
        emit setCalibrationPatternSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setColorfrontConfig(const OAIColorfrontConfig &oai_colorfront_config) {
    QString fullPath = QString(_serverConfigs["setColorfrontConfig"][_serverIndices.value("setColorfrontConfig")].URL()+"/colorfrontConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_colorfront_config.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setColorfrontConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setColorfrontConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setColorfrontConfigSignal();
        emit setColorfrontConfigSignalFull(worker);
    } else {
        emit setColorfrontConfigSignalE(error_type, error_str);
        emit setColorfrontConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setConfigForGivenNetDeviceIndex(const qint32 &dev_idx, const OAINetConfig &oai_net_config) {
    QString fullPath = QString(_serverConfigs["setConfigForGivenNetDeviceIndex"][_serverIndices.value("setConfigForGivenNetDeviceIndex")].URL()+"/net/device/{devIdx}/config");
    
    
    {
        QString dev_idxPathParam("{");
        dev_idxPathParam.append("devIdx").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "devIdx", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"devIdx"+pathSuffix : pathPrefix;
        fullPath.replace(dev_idxPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dev_idx)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_net_config.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setConfigForGivenNetDeviceIndexCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setConfigForGivenNetDeviceIndexCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setConfigForGivenNetDeviceIndexSignal();
        emit setConfigForGivenNetDeviceIndexSignalFull(worker);
    } else {
        emit setConfigForGivenNetDeviceIndexSignalE(error_type, error_str);
        emit setConfigForGivenNetDeviceIndexSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setFrameStore(const OAIFrameStore &oai_frame_store) {
    QString fullPath = QString(_serverConfigs["setFrameStore"][_serverIndices.value("setFrameStore")].URL()+"/frameStore");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_frame_store.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setFrameStoreCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setFrameStoreCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setFrameStoreSignal();
        emit setFrameStoreSignalFull(worker);
    } else {
        emit setFrameStoreSignalE(error_type, error_str);
        emit setFrameStoreSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setLibraryControl(const OAILibraryControl &oai_library_control) {
    QString fullPath = QString(_serverConfigs["setLibraryControl"][_serverIndices.value("setLibraryControl")].URL()+"/libraryControl");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_library_control.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setLibraryControlCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setLibraryControlCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setLibraryControlSignal();
        emit setLibraryControlSignalFull(worker);
    } else {
        emit setLibraryControlSignalE(error_type, error_str);
        emit setLibraryControlSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setLicenseGenerationRequest() {
    QString fullPath = QString(_serverConfigs["setLicenseGenerationRequest"][_serverIndices.value("setLicenseGenerationRequest")].URL()+"/licenseGenerationRequest");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setLicenseGenerationRequestCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setLicenseGenerationRequestCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setLicenseGenerationRequestSignal();
        emit setLicenseGenerationRequestSignalFull(worker);
    } else {
        emit setLicenseGenerationRequestSignalE(error_type, error_str);
        emit setLicenseGenerationRequestSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setNbcConfig(const OAINbcConfig &oai_nbc_config) {
    QString fullPath = QString(_serverConfigs["setNbcConfig"][_serverIndices.value("setNbcConfig")].URL()+"/nbcConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_nbc_config.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setNbcConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setNbcConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setNbcConfigSignal();
        emit setNbcConfigSignalFull(worker);
    } else {
        emit setNbcConfigSignalE(error_type, error_str);
        emit setNbcConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setOrionConfig(const OAIOrionConfig &oai_orion_config) {
    QString fullPath = QString(_serverConfigs["setOrionConfig"][_serverIndices.value("setOrionConfig")].URL()+"/orionConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_orion_config.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setOrionConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setOrionConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setOrionConfigSignal();
        emit setOrionConfigSignalFull(worker);
    } else {
        emit setOrionConfigSignalE(error_type, error_str);
        emit setOrionConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setOutputConfig(const OAIOutputConfig &oai_output_config) {
    QString fullPath = QString(_serverConfigs["setOutputConfig"][_serverIndices.value("setOutputConfig")].URL()+"/outputConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_output_config.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setOutputConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setOutputConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setOutputConfigSignal();
        emit setOutputConfigSignalFull(worker);
    } else {
        emit setOutputConfigSignalE(error_type, error_str);
        emit setOutputConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setOutputStatus(const OAIOutputConfig &oai_output_config) {
    QString fullPath = QString(_serverConfigs["setOutputStatus"][_serverIndices.value("setOutputStatus")].URL()+"/outputStatus");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_output_config.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setOutputStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setOutputStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setOutputStatusSignal();
        emit setOutputStatusSignalFull(worker);
    } else {
        emit setOutputStatusSignalE(error_type, error_str);
        emit setOutputStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setOverlay(const OAIOverlay &oai_overlay) {
    QString fullPath = QString(_serverConfigs["setOverlay"][_serverIndices.value("setOverlay")].URL()+"/overlay");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_overlay.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setOverlayCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setOverlayCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setOverlaySignal();
        emit setOverlaySignalFull(worker);
    } else {
        emit setOverlaySignalE(error_type, error_str);
        emit setOverlaySignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setPipelineStages(const OAIPipelineStages &oai_pipeline_stages) {
    QString fullPath = QString(_serverConfigs["setPipelineStages"][_serverIndices.value("setPipelineStages")].URL()+"/pipelineStages");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_pipeline_stages.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setPipelineStagesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setPipelineStagesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setPipelineStagesSignal();
        emit setPipelineStagesSignalFull(worker);
    } else {
        emit setPipelineStagesSignalE(error_type, error_str);
        emit setPipelineStagesSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setPreviewImage(const ::OpenAPI::OptionalParam<OAIPreview> &oai_preview) {
    QString fullPath = QString(_serverConfigs["setPreviewImage"][_serverIndices.value("setPreviewImage")].URL()+"/preview");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (oai_preview.hasValue()){

        QByteArray output = oai_preview.value().asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setPreviewImageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setPreviewImageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setPreviewImageSignal();
        emit setPreviewImageSignalFull(worker);
    } else {
        emit setPreviewImageSignalE(error_type, error_str);
        emit setPreviewImageSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setRouting(const OAIRouting &oai_routing) {
    QString fullPath = QString(_serverConfigs["setRouting"][_serverIndices.value("setRouting")].URL()+"/routing");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_routing.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setRoutingCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setRoutingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setRoutingSignal();
        emit setRoutingSignalFull(worker);
    } else {
        emit setRoutingSignalE(error_type, error_str);
        emit setRoutingSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setSdiInputConfig(const OAISDI &oaisdi) {
    QString fullPath = QString(_serverConfigs["setSdiInputConfig"][_serverIndices.value("setSdiInputConfig")].URL()+"/sdiInputConfig");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oaisdi.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setSdiInputConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setSdiInputConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setSdiInputConfigSignal();
        emit setSdiInputConfigSignalFull(worker);
    } else {
        emit setSdiInputConfigSignalE(error_type, error_str);
        emit setSdiInputConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setSdiInputStatus(const OAISDI &oaisdi) {
    QString fullPath = QString(_serverConfigs["setSdiInputStatus"][_serverIndices.value("setSdiInputStatus")].URL()+"/sdiInputStatus");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oaisdi.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setSdiInputStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setSdiInputStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setSdiInputStatusSignal();
        emit setSdiInputStatusSignalFull(worker);
    } else {
        emit setSdiInputStatusSignalE(error_type, error_str);
        emit setSdiInputStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setStagedParamsForGivenNetDeviceIndex(const qint32 &dev_idx, const OAINetParams &oai_net_params) {
    QString fullPath = QString(_serverConfigs["setStagedParamsForGivenNetDeviceIndex"][_serverIndices.value("setStagedParamsForGivenNetDeviceIndex")].URL()+"/net/device/{devIdx}/stagedParams");
    
    
    {
        QString dev_idxPathParam("{");
        dev_idxPathParam.append("devIdx").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "devIdx", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"devIdx"+pathSuffix : pathPrefix;
        fullPath.replace(dev_idxPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dev_idx)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_net_params.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setStagedParamsForGivenNetDeviceIndexCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setStagedParamsForGivenNetDeviceIndexCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setStagedParamsForGivenNetDeviceIndexSignal();
        emit setStagedParamsForGivenNetDeviceIndexSignalFull(worker);
    } else {
        emit setStagedParamsForGivenNetDeviceIndexSignalE(error_type, error_str);
        emit setStagedParamsForGivenNetDeviceIndexSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setStatusForGivenNetDeviceIndex(const qint32 &dev_idx, const OAINetStatus &oai_net_status) {
    QString fullPath = QString(_serverConfigs["setStatusForGivenNetDeviceIndex"][_serverIndices.value("setStatusForGivenNetDeviceIndex")].URL()+"/net/device/{devIdx}/status");
    
    if (_apiKeys.contains("app_id")) {
        addHeaders("app_id",_apiKeys.find("app_id").value());
    }
    
    
    {
        QString dev_idxPathParam("{");
        dev_idxPathParam.append("devIdx").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "devIdx", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"devIdx"+pathSuffix : pathPrefix;
        fullPath.replace(dev_idxPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dev_idx)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_net_status.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setStatusForGivenNetDeviceIndexCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setStatusForGivenNetDeviceIndexCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setStatusForGivenNetDeviceIndexSignal();
        emit setStatusForGivenNetDeviceIndexSignalFull(worker);
    } else {
        emit setStatusForGivenNetDeviceIndexSignalE(error_type, error_str);
        emit setStatusForGivenNetDeviceIndexSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setSystemConfig(const OAISystemConfig &oai_system_config) {
    QString fullPath = QString(_serverConfigs["setSystemConfig"][_serverIndices.value("setSystemConfig")].URL()+"/system/config");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_system_config.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setSystemConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setSystemConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setSystemConfigSignal();
        emit setSystemConfigSignalFull(worker);
    } else {
        emit setSystemConfigSignalE(error_type, error_str);
        emit setSystemConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setSystemPassword(const OAISystemPassword &oai_system_password) {
    QString fullPath = QString(_serverConfigs["setSystemPassword"][_serverIndices.value("setSystemPassword")].URL()+"/system/password");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_system_password.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setSystemPasswordCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setSystemPasswordCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISystemPasswordResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setSystemPasswordSignal(output);
        emit setSystemPasswordSignalFull(worker, output);
    } else {
        emit setSystemPasswordSignalE(output, error_type, error_str);
        emit setSystemPasswordSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setSystemStatus(const OAISystemStatus &oai_system_status) {
    QString fullPath = QString(_serverConfigs["setSystemStatus"][_serverIndices.value("setSystemStatus")].URL()+"/system/status");
    
    if (_apiKeys.contains("app_id")) {
        addHeaders("app_id",_apiKeys.find("app_id").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oai_system_status.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setSystemStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setSystemStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setSystemStatusSignal();
        emit setSystemStatusSignalFull(worker);
    } else {
        emit setSystemStatusSignalE(error_type, error_str);
        emit setSystemStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setWiFiConfig(const OAIWiFiDeviceConfig &oaiwi_fi_device_config) {
    QString fullPath = QString(_serverConfigs["setWiFiConfig"][_serverIndices.value("setWiFiConfig")].URL()+"/wifiConfig");
    
    if (_apiKeys.contains("app_id")) {
        addHeaders("app_id",_apiKeys.find("app_id").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oaiwi_fi_device_config.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setWiFiConfigCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setWiFiConfigCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setWiFiConfigSignal();
        emit setWiFiConfigSignalFull(worker);
    } else {
        emit setWiFiConfigSignalE(error_type, error_str);
        emit setWiFiConfigSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setWiFiStatus(const OAIWiFiDeviceStatus &oaiwi_fi_device_status) {
    QString fullPath = QString(_serverConfigs["setWiFiStatus"][_serverIndices.value("setWiFiStatus")].URL()+"/wifiStatus");
    
    if (_apiKeys.contains("app_id")) {
        addHeaders("app_id",_apiKeys.find("app_id").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        QByteArray output = oaiwi_fi_device_status.asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setWiFiStatusCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setWiFiStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit setWiFiStatusSignal();
        emit setWiFiStatusSignalFull(worker);
    } else {
        emit setWiFiStatusSignalE(error_type, error_str);
        emit setWiFiStatusSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::uploadFile(const ::OpenAPI::OptionalParam<OAIHttpFileElement> &file, const ::OpenAPI::OptionalParam<QString> &kind, const ::OpenAPI::OptionalParam<qint32> &entry) {
    QString fullPath = QString(_serverConfigs["uploadFile"][_serverIndices.value("uploadFile")].URL()+"/upload");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (file.hasValue())
    {
        input.add_file("file", file.value().local_filename, file.value().request_filename, file.value().mime_type);
    }
    if (kind.hasValue())
    {
        input.add_var("kind", ::OpenAPI::toStringValue(kind.value()));
    }
    if (entry.hasValue())
    {
        input.add_var("entry", ::OpenAPI::toStringValue(entry.value()));
    }

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::uploadFileCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::uploadFileCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit uploadFileSignal();
        emit uploadFileSignalFull(worker);
    } else {
        emit uploadFileSignalE(error_type, error_str);
        emit uploadFileSignalEFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::tokenAvailable(){

	qDebug() << "No Oauth functionality available!";
}
} // namespace OpenAPI
