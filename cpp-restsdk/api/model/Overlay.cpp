/**
 * OpenAPI ColorBox
 * This is a REST API for the AJA ColorBox product.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@aja.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.4.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 * Copyright (C) 2020-2022 AJA Video Systems Inc.  All rights reserved.
 */



#include "Overlay.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




Overlay::Overlay()
{
    m_Enabled = false;
    m_EnabledIsSet = false;
    m_InVpidFormat = false;
    m_InVpidFormatIsSet = false;
    m_InVpidRange = false;
    m_InVpidRangeIsSet = false;
    m_InVpidHdr = false;
    m_InVpidHdrIsSet = false;
    m_InVpidBitDepth = false;
    m_InVpidBitDepthIsSet = false;
    m_OutVpidFormat = false;
    m_OutVpidFormatIsSet = false;
    m_OutVpidRange = false;
    m_OutVpidRangeIsSet = false;
    m_OutVpidHdr = false;
    m_OutVpidHdrIsSet = false;
    m_OutVpidBitDepth = false;
    m_OutVpidBitDepthIsSet = false;
    m_TimeCode = false;
    m_TimeCodeIsSet = false;
    m_ClosedCaption = false;
    m_ClosedCaptionIsSet = false;
    m_UserTextEnabled = false;
    m_UserTextEnabledIsSet = false;
    m_UserTextLine1 = utility::conversions::to_string_t("");
    m_UserTextLine1IsSet = false;
    m_UserTextLine2 = utility::conversions::to_string_t("");
    m_UserTextLine2IsSet = false;
    m_PipelineConfig = false;
    m_PipelineConfigIsSet = false;
    m_LocationIsSet = false;
}

Overlay::~Overlay()
{
}

void Overlay::validate()
{
    // TODO: implement validation
}

bool Overlay::applyMinMaxConstraints()
{
	bool anyMinMaxValueChanged = false;
	if (userTextLine1IsSet())
	{
		bool userTextLine1Changed = false;
		utility::string_t v = getUserTextLine1();
		int min = userTextLine1Min();
		int max = userTextLine1Max();
		if (v.length() < (size_t)min) { v.resize(min); userTextLine1Changed = true; }
		if (v.length() > (size_t)max) { v.resize(max); userTextLine1Changed = true; }
		if (userTextLine1Changed) { setUserTextLine1(v); anyMinMaxValueChanged = true; }
	}
	if (userTextLine2IsSet())
	{
		bool userTextLine2Changed = false;
		utility::string_t v = getUserTextLine2();
		int min = userTextLine2Min();
		int max = userTextLine2Max();
		if (v.length() < (size_t)min) { v.resize(min); userTextLine2Changed = true; }
		if (v.length() > (size_t)max) { v.resize(max); userTextLine2Changed = true; }
		if (userTextLine2Changed) { setUserTextLine2(v); anyMinMaxValueChanged = true; }
	}
	return anyMinMaxValueChanged;
}

web::json::value Overlay::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_EnabledIsSet)
    {
        val[utility::conversions::to_string_t(U("enabled"))] = ModelBase::toJson(m_Enabled);
    }
    if(m_InVpidFormatIsSet)
    {
        val[utility::conversions::to_string_t(U("inVpidFormat"))] = ModelBase::toJson(m_InVpidFormat);
    }
    if(m_InVpidRangeIsSet)
    {
        val[utility::conversions::to_string_t(U("inVpidRange"))] = ModelBase::toJson(m_InVpidRange);
    }
    if(m_InVpidHdrIsSet)
    {
        val[utility::conversions::to_string_t(U("inVpidHdr"))] = ModelBase::toJson(m_InVpidHdr);
    }
    if(m_InVpidBitDepthIsSet)
    {
        val[utility::conversions::to_string_t(U("inVpidBitDepth"))] = ModelBase::toJson(m_InVpidBitDepth);
    }
    if(m_OutVpidFormatIsSet)
    {
        val[utility::conversions::to_string_t(U("outVpidFormat"))] = ModelBase::toJson(m_OutVpidFormat);
    }
    if(m_OutVpidRangeIsSet)
    {
        val[utility::conversions::to_string_t(U("outVpidRange"))] = ModelBase::toJson(m_OutVpidRange);
    }
    if(m_OutVpidHdrIsSet)
    {
        val[utility::conversions::to_string_t(U("outVpidHdr"))] = ModelBase::toJson(m_OutVpidHdr);
    }
    if(m_OutVpidBitDepthIsSet)
    {
        val[utility::conversions::to_string_t(U("outVpidBitDepth"))] = ModelBase::toJson(m_OutVpidBitDepth);
    }
    if(m_TimeCodeIsSet)
    {
        val[utility::conversions::to_string_t(U("timeCode"))] = ModelBase::toJson(m_TimeCode);
    }
    if(m_ClosedCaptionIsSet)
    {
        val[utility::conversions::to_string_t(U("closedCaption"))] = ModelBase::toJson(m_ClosedCaption);
    }
    if(m_UserTextEnabledIsSet)
    {
        val[utility::conversions::to_string_t(U("userTextEnabled"))] = ModelBase::toJson(m_UserTextEnabled);
    }
    if(m_UserTextLine1IsSet)
    {
        val[utility::conversions::to_string_t(U("userTextLine1"))] = ModelBase::toJson(m_UserTextLine1);
    }
    if(m_UserTextLine2IsSet)
    {
        val[utility::conversions::to_string_t(U("userTextLine2"))] = ModelBase::toJson(m_UserTextLine2);
    }
    if(m_PipelineConfigIsSet)
    {
        val[utility::conversions::to_string_t(U("pipelineConfig"))] = ModelBase::toJson(m_PipelineConfig);
    }
    if(m_LocationIsSet)
    {
        val[utility::conversions::to_string_t(U("location"))] = ModelBase::toJson(m_Location);
    }

    return val;
}

bool Overlay::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("enabled"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("enabled")));
        if(!fieldValue.is_null())
        {
            bool refVal_enabled;
            ok &= ModelBase::fromJson(fieldValue, refVal_enabled);
            setEnabled(refVal_enabled);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("inVpidFormat"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("inVpidFormat")));
        if(!fieldValue.is_null())
        {
            bool refVal_inVpidFormat;
            ok &= ModelBase::fromJson(fieldValue, refVal_inVpidFormat);
            setInVpidFormat(refVal_inVpidFormat);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("inVpidRange"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("inVpidRange")));
        if(!fieldValue.is_null())
        {
            bool refVal_inVpidRange;
            ok &= ModelBase::fromJson(fieldValue, refVal_inVpidRange);
            setInVpidRange(refVal_inVpidRange);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("inVpidHdr"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("inVpidHdr")));
        if(!fieldValue.is_null())
        {
            bool refVal_inVpidHdr;
            ok &= ModelBase::fromJson(fieldValue, refVal_inVpidHdr);
            setInVpidHdr(refVal_inVpidHdr);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("inVpidBitDepth"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("inVpidBitDepth")));
        if(!fieldValue.is_null())
        {
            bool refVal_inVpidBitDepth;
            ok &= ModelBase::fromJson(fieldValue, refVal_inVpidBitDepth);
            setInVpidBitDepth(refVal_inVpidBitDepth);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("outVpidFormat"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("outVpidFormat")));
        if(!fieldValue.is_null())
        {
            bool refVal_outVpidFormat;
            ok &= ModelBase::fromJson(fieldValue, refVal_outVpidFormat);
            setOutVpidFormat(refVal_outVpidFormat);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("outVpidRange"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("outVpidRange")));
        if(!fieldValue.is_null())
        {
            bool refVal_outVpidRange;
            ok &= ModelBase::fromJson(fieldValue, refVal_outVpidRange);
            setOutVpidRange(refVal_outVpidRange);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("outVpidHdr"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("outVpidHdr")));
        if(!fieldValue.is_null())
        {
            bool refVal_outVpidHdr;
            ok &= ModelBase::fromJson(fieldValue, refVal_outVpidHdr);
            setOutVpidHdr(refVal_outVpidHdr);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("outVpidBitDepth"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("outVpidBitDepth")));
        if(!fieldValue.is_null())
        {
            bool refVal_outVpidBitDepth;
            ok &= ModelBase::fromJson(fieldValue, refVal_outVpidBitDepth);
            setOutVpidBitDepth(refVal_outVpidBitDepth);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("timeCode"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("timeCode")));
        if(!fieldValue.is_null())
        {
            bool refVal_timeCode;
            ok &= ModelBase::fromJson(fieldValue, refVal_timeCode);
            setTimeCode(refVal_timeCode);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("closedCaption"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("closedCaption")));
        if(!fieldValue.is_null())
        {
            bool refVal_closedCaption;
            ok &= ModelBase::fromJson(fieldValue, refVal_closedCaption);
            setClosedCaption(refVal_closedCaption);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("userTextEnabled"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("userTextEnabled")));
        if(!fieldValue.is_null())
        {
            bool refVal_userTextEnabled;
            ok &= ModelBase::fromJson(fieldValue, refVal_userTextEnabled);
            setUserTextEnabled(refVal_userTextEnabled);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("userTextLine1"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("userTextLine1")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_userTextLine1;
            ok &= ModelBase::fromJson(fieldValue, refVal_userTextLine1);
            setUserTextLine1(refVal_userTextLine1);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("userTextLine2"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("userTextLine2")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_userTextLine2;
            ok &= ModelBase::fromJson(fieldValue, refVal_userTextLine2);
            setUserTextLine2(refVal_userTextLine2);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("pipelineConfig"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("pipelineConfig")));
        if(!fieldValue.is_null())
        {
            bool refVal_pipelineConfig;
            ok &= ModelBase::fromJson(fieldValue, refVal_pipelineConfig);
            setPipelineConfig(refVal_pipelineConfig);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("location"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("location")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Locations> refVal_location;
            ok &= ModelBase::fromJson(fieldValue, refVal_location);
            setLocation(refVal_location);
        }
    }
    
    applyMinMaxConstraints();
    return ok;
}

void Overlay::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_EnabledIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("enabled")), m_Enabled));
    }
    if(m_InVpidFormatIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("inVpidFormat")), m_InVpidFormat));
    }
    if(m_InVpidRangeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("inVpidRange")), m_InVpidRange));
    }
    if(m_InVpidHdrIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("inVpidHdr")), m_InVpidHdr));
    }
    if(m_InVpidBitDepthIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("inVpidBitDepth")), m_InVpidBitDepth));
    }
    if(m_OutVpidFormatIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("outVpidFormat")), m_OutVpidFormat));
    }
    if(m_OutVpidRangeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("outVpidRange")), m_OutVpidRange));
    }
    if(m_OutVpidHdrIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("outVpidHdr")), m_OutVpidHdr));
    }
    if(m_OutVpidBitDepthIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("outVpidBitDepth")), m_OutVpidBitDepth));
    }
    if(m_TimeCodeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("timeCode")), m_TimeCode));
    }
    if(m_ClosedCaptionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("closedCaption")), m_ClosedCaption));
    }
    if(m_UserTextEnabledIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("userTextEnabled")), m_UserTextEnabled));
    }
    if(m_UserTextLine1IsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("userTextLine1")), m_UserTextLine1));
    }
    if(m_UserTextLine2IsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("userTextLine2")), m_UserTextLine2));
    }
    if(m_PipelineConfigIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("pipelineConfig")), m_PipelineConfig));
    }
    if(m_LocationIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("location")), m_Location));
    }
}

bool Overlay::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("enabled"))))
    {
        bool refVal_enabled;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("enabled"))), refVal_enabled );
        setEnabled(refVal_enabled);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("inVpidFormat"))))
    {
        bool refVal_inVpidFormat;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("inVpidFormat"))), refVal_inVpidFormat );
        setInVpidFormat(refVal_inVpidFormat);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("inVpidRange"))))
    {
        bool refVal_inVpidRange;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("inVpidRange"))), refVal_inVpidRange );
        setInVpidRange(refVal_inVpidRange);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("inVpidHdr"))))
    {
        bool refVal_inVpidHdr;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("inVpidHdr"))), refVal_inVpidHdr );
        setInVpidHdr(refVal_inVpidHdr);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("inVpidBitDepth"))))
    {
        bool refVal_inVpidBitDepth;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("inVpidBitDepth"))), refVal_inVpidBitDepth );
        setInVpidBitDepth(refVal_inVpidBitDepth);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("outVpidFormat"))))
    {
        bool refVal_outVpidFormat;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("outVpidFormat"))), refVal_outVpidFormat );
        setOutVpidFormat(refVal_outVpidFormat);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("outVpidRange"))))
    {
        bool refVal_outVpidRange;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("outVpidRange"))), refVal_outVpidRange );
        setOutVpidRange(refVal_outVpidRange);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("outVpidHdr"))))
    {
        bool refVal_outVpidHdr;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("outVpidHdr"))), refVal_outVpidHdr );
        setOutVpidHdr(refVal_outVpidHdr);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("outVpidBitDepth"))))
    {
        bool refVal_outVpidBitDepth;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("outVpidBitDepth"))), refVal_outVpidBitDepth );
        setOutVpidBitDepth(refVal_outVpidBitDepth);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("timeCode"))))
    {
        bool refVal_timeCode;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("timeCode"))), refVal_timeCode );
        setTimeCode(refVal_timeCode);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("closedCaption"))))
    {
        bool refVal_closedCaption;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("closedCaption"))), refVal_closedCaption );
        setClosedCaption(refVal_closedCaption);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("userTextEnabled"))))
    {
        bool refVal_userTextEnabled;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("userTextEnabled"))), refVal_userTextEnabled );
        setUserTextEnabled(refVal_userTextEnabled);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("userTextLine1"))))
    {
        utility::string_t refVal_userTextLine1;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("userTextLine1"))), refVal_userTextLine1 );
        setUserTextLine1(refVal_userTextLine1);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("userTextLine2"))))
    {
        utility::string_t refVal_userTextLine2;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("userTextLine2"))), refVal_userTextLine2 );
        setUserTextLine2(refVal_userTextLine2);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("pipelineConfig"))))
    {
        bool refVal_pipelineConfig;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("pipelineConfig"))), refVal_pipelineConfig );
        setPipelineConfig(refVal_pipelineConfig);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("location"))))
    {
        std::shared_ptr<Locations> refVal_location;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("location"))), refVal_location );
        setLocation(refVal_location);
    }
    
    applyMinMaxConstraints();
    return ok;
}

bool Overlay::isEnabled() const
{
    return m_Enabled;
}

void Overlay::setEnabled(bool value)
{
	bool v = value;
    m_Enabled = v;
    m_EnabledIsSet = true;
}

bool Overlay::enabledIsSet() const
{
    return m_EnabledIsSet;
}

void Overlay::unsetEnabled()
{
    m_EnabledIsSet = false;
}


bool Overlay::isInVpidFormat() const
{
    return m_InVpidFormat;
}

void Overlay::setInVpidFormat(bool value)
{
	bool v = value;
    m_InVpidFormat = v;
    m_InVpidFormatIsSet = true;
}

bool Overlay::inVpidFormatIsSet() const
{
    return m_InVpidFormatIsSet;
}

void Overlay::unsetInVpidFormat()
{
    m_InVpidFormatIsSet = false;
}


bool Overlay::isInVpidRange() const
{
    return m_InVpidRange;
}

void Overlay::setInVpidRange(bool value)
{
	bool v = value;
    m_InVpidRange = v;
    m_InVpidRangeIsSet = true;
}

bool Overlay::inVpidRangeIsSet() const
{
    return m_InVpidRangeIsSet;
}

void Overlay::unsetInVpidRange()
{
    m_InVpidRangeIsSet = false;
}


bool Overlay::isInVpidHdr() const
{
    return m_InVpidHdr;
}

void Overlay::setInVpidHdr(bool value)
{
	bool v = value;
    m_InVpidHdr = v;
    m_InVpidHdrIsSet = true;
}

bool Overlay::inVpidHdrIsSet() const
{
    return m_InVpidHdrIsSet;
}

void Overlay::unsetInVpidHdr()
{
    m_InVpidHdrIsSet = false;
}


bool Overlay::isInVpidBitDepth() const
{
    return m_InVpidBitDepth;
}

void Overlay::setInVpidBitDepth(bool value)
{
	bool v = value;
    m_InVpidBitDepth = v;
    m_InVpidBitDepthIsSet = true;
}

bool Overlay::inVpidBitDepthIsSet() const
{
    return m_InVpidBitDepthIsSet;
}

void Overlay::unsetInVpidBitDepth()
{
    m_InVpidBitDepthIsSet = false;
}


bool Overlay::isOutVpidFormat() const
{
    return m_OutVpidFormat;
}

void Overlay::setOutVpidFormat(bool value)
{
	bool v = value;
    m_OutVpidFormat = v;
    m_OutVpidFormatIsSet = true;
}

bool Overlay::outVpidFormatIsSet() const
{
    return m_OutVpidFormatIsSet;
}

void Overlay::unsetOutVpidFormat()
{
    m_OutVpidFormatIsSet = false;
}


bool Overlay::isOutVpidRange() const
{
    return m_OutVpidRange;
}

void Overlay::setOutVpidRange(bool value)
{
	bool v = value;
    m_OutVpidRange = v;
    m_OutVpidRangeIsSet = true;
}

bool Overlay::outVpidRangeIsSet() const
{
    return m_OutVpidRangeIsSet;
}

void Overlay::unsetOutVpidRange()
{
    m_OutVpidRangeIsSet = false;
}


bool Overlay::isOutVpidHdr() const
{
    return m_OutVpidHdr;
}

void Overlay::setOutVpidHdr(bool value)
{
	bool v = value;
    m_OutVpidHdr = v;
    m_OutVpidHdrIsSet = true;
}

bool Overlay::outVpidHdrIsSet() const
{
    return m_OutVpidHdrIsSet;
}

void Overlay::unsetOutVpidHdr()
{
    m_OutVpidHdrIsSet = false;
}


bool Overlay::isOutVpidBitDepth() const
{
    return m_OutVpidBitDepth;
}

void Overlay::setOutVpidBitDepth(bool value)
{
	bool v = value;
    m_OutVpidBitDepth = v;
    m_OutVpidBitDepthIsSet = true;
}

bool Overlay::outVpidBitDepthIsSet() const
{
    return m_OutVpidBitDepthIsSet;
}

void Overlay::unsetOutVpidBitDepth()
{
    m_OutVpidBitDepthIsSet = false;
}


bool Overlay::isTimeCode() const
{
    return m_TimeCode;
}

void Overlay::setTimeCode(bool value)
{
	bool v = value;
    m_TimeCode = v;
    m_TimeCodeIsSet = true;
}

bool Overlay::timeCodeIsSet() const
{
    return m_TimeCodeIsSet;
}

void Overlay::unsetTimeCode()
{
    m_TimeCodeIsSet = false;
}


bool Overlay::isClosedCaption() const
{
    return m_ClosedCaption;
}

void Overlay::setClosedCaption(bool value)
{
	bool v = value;
    m_ClosedCaption = v;
    m_ClosedCaptionIsSet = true;
}

bool Overlay::closedCaptionIsSet() const
{
    return m_ClosedCaptionIsSet;
}

void Overlay::unsetClosedCaption()
{
    m_ClosedCaptionIsSet = false;
}


bool Overlay::isUserTextEnabled() const
{
    return m_UserTextEnabled;
}

void Overlay::setUserTextEnabled(bool value)
{
	bool v = value;
    m_UserTextEnabled = v;
    m_UserTextEnabledIsSet = true;
}

bool Overlay::userTextEnabledIsSet() const
{
    return m_UserTextEnabledIsSet;
}

void Overlay::unsetUserTextEnabled()
{
    m_UserTextEnabledIsSet = false;
}


utility::string_t Overlay::getUserTextLine1() const
{
    return m_UserTextLine1;
}

void Overlay::setUserTextLine1(const utility::string_t& value)
{
	utility::string_t v = value;
	int min = userTextLine1Min();
	int max = userTextLine1Max();
	if (v.length() < (size_t)min) { v.resize(min); }
	if (v.length() > (size_t)max) { v.resize(max); }
    m_UserTextLine1 = v;
    m_UserTextLine1IsSet = true;
}

bool Overlay::userTextLine1IsSet() const
{
    return m_UserTextLine1IsSet;
}

void Overlay::unsetUserTextLine1()
{
    m_UserTextLine1IsSet = false;
}

int Overlay::userTextLine1Min() const {
	return 0;
}

int Overlay::userTextLine1Max() const {
	return 110;
}

utility::string_t Overlay::getUserTextLine2() const
{
    return m_UserTextLine2;
}

void Overlay::setUserTextLine2(const utility::string_t& value)
{
	utility::string_t v = value;
	int min = userTextLine2Min();
	int max = userTextLine2Max();
	if (v.length() < (size_t)min) { v.resize(min); }
	if (v.length() > (size_t)max) { v.resize(max); }
    m_UserTextLine2 = v;
    m_UserTextLine2IsSet = true;
}

bool Overlay::userTextLine2IsSet() const
{
    return m_UserTextLine2IsSet;
}

void Overlay::unsetUserTextLine2()
{
    m_UserTextLine2IsSet = false;
}

int Overlay::userTextLine2Min() const {
	return 0;
}

int Overlay::userTextLine2Max() const {
	return 110;
}

bool Overlay::isPipelineConfig() const
{
    return m_PipelineConfig;
}

void Overlay::setPipelineConfig(bool value)
{
	bool v = value;
    m_PipelineConfig = v;
    m_PipelineConfigIsSet = true;
}

bool Overlay::pipelineConfigIsSet() const
{
    return m_PipelineConfigIsSet;
}

void Overlay::unsetPipelineConfig()
{
    m_PipelineConfigIsSet = false;
}


std::shared_ptr<Locations> Overlay::getLocation() const
{
    return m_Location;
}

void Overlay::setLocation(const std::shared_ptr<Locations>& value)
{
	std::shared_ptr<Locations> v = value;
    m_Location = v;
    m_LocationIsSet = true;
}

bool Overlay::locationIsSet() const
{
    return m_LocationIsSet;
}

void Overlay::unsetLocation()
{
    m_LocationIsSet = false;
}


}
}
}
}


