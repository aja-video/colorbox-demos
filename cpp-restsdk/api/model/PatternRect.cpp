/**
 * OpenAPI ColorBox
 * This is a REST API for the AJA ColorBox product.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@aja.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.4.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 * Copyright (C) 2020-2022 AJA Video Systems Inc.  All rights reserved.
 */



#include "PatternRect.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




PatternRect::PatternRect()
{
    m_Xstart = 0.0;
    m_XstartIsSet = false;
    m_Ystart = 0.0;
    m_YstartIsSet = false;
    m_Width = 0.0;
    m_WidthIsSet = false;
    m_Height = 0.0;
    m_HeightIsSet = false;
}

PatternRect::~PatternRect()
{
}

void PatternRect::validate()
{
    // TODO: implement validation
}

bool PatternRect::applyMinMaxConstraints()
{
	bool anyMinMaxValueChanged = false;
	if (xstartIsSet())
	{
		bool xstartChanged = false;
		double v = getXstart();
		double min = xstartMin();
		double max = xstartMax();
		if (v < min) { v = min; xstartChanged = true; }
		if (v > max) { v = max; xstartChanged = true; }
		if (xstartChanged) { setXstart(v); anyMinMaxValueChanged = true; }
	}
	if (ystartIsSet())
	{
		bool ystartChanged = false;
		double v = getYstart();
		double min = ystartMin();
		double max = ystartMax();
		if (v < min) { v = min; ystartChanged = true; }
		if (v > max) { v = max; ystartChanged = true; }
		if (ystartChanged) { setYstart(v); anyMinMaxValueChanged = true; }
	}
	if (widthIsSet())
	{
		bool widthChanged = false;
		double v = getWidth();
		double min = widthMin();
		double max = widthMax();
		if (v < min) { v = min; widthChanged = true; }
		if (v > max) { v = max; widthChanged = true; }
		if (widthChanged) { setWidth(v); anyMinMaxValueChanged = true; }
	}
	if (heightIsSet())
	{
		bool heightChanged = false;
		double v = getHeight();
		double min = heightMin();
		double max = heightMax();
		if (v < min) { v = min; heightChanged = true; }
		if (v > max) { v = max; heightChanged = true; }
		if (heightChanged) { setHeight(v); anyMinMaxValueChanged = true; }
	}
	return anyMinMaxValueChanged;
}

web::json::value PatternRect::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_XstartIsSet)
    {
        val[utility::conversions::to_string_t(U("xstart"))] = ModelBase::toJson(m_Xstart);
    }
    if(m_YstartIsSet)
    {
        val[utility::conversions::to_string_t(U("ystart"))] = ModelBase::toJson(m_Ystart);
    }
    if(m_WidthIsSet)
    {
        val[utility::conversions::to_string_t(U("width"))] = ModelBase::toJson(m_Width);
    }
    if(m_HeightIsSet)
    {
        val[utility::conversions::to_string_t(U("height"))] = ModelBase::toJson(m_Height);
    }

    return val;
}

bool PatternRect::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("xstart"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("xstart")));
        if(!fieldValue.is_null())
        {
            double refVal_xstart;
            ok &= ModelBase::fromJson(fieldValue, refVal_xstart);
            setXstart(refVal_xstart);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("ystart"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("ystart")));
        if(!fieldValue.is_null())
        {
            double refVal_ystart;
            ok &= ModelBase::fromJson(fieldValue, refVal_ystart);
            setYstart(refVal_ystart);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("width"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("width")));
        if(!fieldValue.is_null())
        {
            double refVal_width;
            ok &= ModelBase::fromJson(fieldValue, refVal_width);
            setWidth(refVal_width);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("height"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("height")));
        if(!fieldValue.is_null())
        {
            double refVal_height;
            ok &= ModelBase::fromJson(fieldValue, refVal_height);
            setHeight(refVal_height);
        }
    }
    
    applyMinMaxConstraints();
    return ok;
}

void PatternRect::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_XstartIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("xstart")), m_Xstart));
    }
    if(m_YstartIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("ystart")), m_Ystart));
    }
    if(m_WidthIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("width")), m_Width));
    }
    if(m_HeightIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("height")), m_Height));
    }
}

bool PatternRect::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("xstart"))))
    {
        double refVal_xstart;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("xstart"))), refVal_xstart );
        setXstart(refVal_xstart);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("ystart"))))
    {
        double refVal_ystart;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("ystart"))), refVal_ystart );
        setYstart(refVal_ystart);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("width"))))
    {
        double refVal_width;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("width"))), refVal_width );
        setWidth(refVal_width);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("height"))))
    {
        double refVal_height;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("height"))), refVal_height );
        setHeight(refVal_height);
    }
    
    applyMinMaxConstraints();
    return ok;
}

double PatternRect::getXstart() const
{
    return m_Xstart;
}

void PatternRect::setXstart(double value)
{
	double v = value;
	double min = xstartMin();
	double max = xstartMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_Xstart = v;
    m_XstartIsSet = true;
}

bool PatternRect::xstartIsSet() const
{
    return m_XstartIsSet;
}

void PatternRect::unsetXstart()
{
    m_XstartIsSet = false;
}

double PatternRect::xstartMin() const {
	return 0.0;
}

double PatternRect::xstartMax() const {
	return 1.0;
}

double PatternRect::getYstart() const
{
    return m_Ystart;
}

void PatternRect::setYstart(double value)
{
	double v = value;
	double min = ystartMin();
	double max = ystartMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_Ystart = v;
    m_YstartIsSet = true;
}

bool PatternRect::ystartIsSet() const
{
    return m_YstartIsSet;
}

void PatternRect::unsetYstart()
{
    m_YstartIsSet = false;
}

double PatternRect::ystartMin() const {
	return 0.0;
}

double PatternRect::ystartMax() const {
	return 1.0;
}

double PatternRect::getWidth() const
{
    return m_Width;
}

void PatternRect::setWidth(double value)
{
	double v = value;
	double min = widthMin();
	double max = widthMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_Width = v;
    m_WidthIsSet = true;
}

bool PatternRect::widthIsSet() const
{
    return m_WidthIsSet;
}

void PatternRect::unsetWidth()
{
    m_WidthIsSet = false;
}

double PatternRect::widthMin() const {
	return 0.0;
}

double PatternRect::widthMax() const {
	return 1.0;
}

double PatternRect::getHeight() const
{
    return m_Height;
}

void PatternRect::setHeight(double value)
{
	double v = value;
	double min = heightMin();
	double max = heightMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_Height = v;
    m_HeightIsSet = true;
}

bool PatternRect::heightIsSet() const
{
    return m_HeightIsSet;
}

void PatternRect::unsetHeight()
{
    m_HeightIsSet = false;
}

double PatternRect::heightMin() const {
	return 0.0;
}

double PatternRect::heightMax() const {
	return 1.0;
}

}
}
}
}


