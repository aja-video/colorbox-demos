/**
 * OpenAPI ColorBox
 * This is a REST API for the AJA ColorBox product.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@aja.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.4.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 * Copyright (C) 2020-2022 AJA Video Systems Inc.  All rights reserved.
 */



#include "StatusInfo.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




StatusInfo::StatusInfo()
{
    m_UpperBoundGood = 0.0;
    m_UpperBoundGoodIsSet = false;
    m_UpperBoundMaybe = 0.0;
    m_UpperBoundMaybeIsSet = false;
    m_Value = utility::conversions::to_string_t("");
    m_ValueIsSet = false;
    m_ValueInt = 0.0;
    m_ValueIntIsSet = false;
    m_Label = utility::conversions::to_string_t("");
    m_LabelIsSet = false;
    m_ExtraValue = utility::conversions::to_string_t("");
    m_ExtraValueIsSet = false;
    m_ExtraLabel = utility::conversions::to_string_t("");
    m_ExtraLabelIsSet = false;
    m_StateIsSet = false;
}

StatusInfo::~StatusInfo()
{
}

void StatusInfo::validate()
{
    // TODO: implement validation
}

bool StatusInfo::applyMinMaxConstraints()
{
	bool anyMinMaxValueChanged = false;
	if (upperBoundGoodIsSet())
	{
		bool upperBoundGoodChanged = false;
		double v = getUpperBoundGood();
		if (upperBoundGoodChanged) { setUpperBoundGood(v); anyMinMaxValueChanged = true; }
	}
	if (upperBoundMaybeIsSet())
	{
		bool upperBoundMaybeChanged = false;
		double v = getUpperBoundMaybe();
		if (upperBoundMaybeChanged) { setUpperBoundMaybe(v); anyMinMaxValueChanged = true; }
	}
	if (valueIsSet())
	{
		bool valueChanged = false;
		utility::string_t v = getValue();
		if (valueChanged) { setValue(v); anyMinMaxValueChanged = true; }
	}
	if (valueIntIsSet())
	{
		bool valueIntChanged = false;
		double v = getValueInt();
		if (valueIntChanged) { setValueInt(v); anyMinMaxValueChanged = true; }
	}
	if (labelIsSet())
	{
		bool labelChanged = false;
		utility::string_t v = getLabel();
		if (labelChanged) { setLabel(v); anyMinMaxValueChanged = true; }
	}
	if (extraValueIsSet())
	{
		bool extraValueChanged = false;
		utility::string_t v = getExtraValue();
		if (extraValueChanged) { setExtraValue(v); anyMinMaxValueChanged = true; }
	}
	if (extraLabelIsSet())
	{
		bool extraLabelChanged = false;
		utility::string_t v = getExtraLabel();
		if (extraLabelChanged) { setExtraLabel(v); anyMinMaxValueChanged = true; }
	}
	return anyMinMaxValueChanged;
}

web::json::value StatusInfo::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_UpperBoundGoodIsSet)
    {
        val[utility::conversions::to_string_t(U("upperBoundGood"))] = ModelBase::toJson(m_UpperBoundGood);
    }
    if(m_UpperBoundMaybeIsSet)
    {
        val[utility::conversions::to_string_t(U("upperBoundMaybe"))] = ModelBase::toJson(m_UpperBoundMaybe);
    }
    if(m_ValueIsSet)
    {
        val[utility::conversions::to_string_t(U("value"))] = ModelBase::toJson(m_Value);
    }
    if(m_ValueIntIsSet)
    {
        val[utility::conversions::to_string_t(U("valueInt"))] = ModelBase::toJson(m_ValueInt);
    }
    if(m_LabelIsSet)
    {
        val[utility::conversions::to_string_t(U("label"))] = ModelBase::toJson(m_Label);
    }
    if(m_ExtraValueIsSet)
    {
        val[utility::conversions::to_string_t(U("extraValue"))] = ModelBase::toJson(m_ExtraValue);
    }
    if(m_ExtraLabelIsSet)
    {
        val[utility::conversions::to_string_t(U("extraLabel"))] = ModelBase::toJson(m_ExtraLabel);
    }
    if(m_StateIsSet)
    {
        val[utility::conversions::to_string_t(U("state"))] = ModelBase::toJson(m_State);
    }

    return val;
}

bool StatusInfo::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("upperBoundGood"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("upperBoundGood")));
        if(!fieldValue.is_null())
        {
            double refVal_upperBoundGood;
            ok &= ModelBase::fromJson(fieldValue, refVal_upperBoundGood);
            setUpperBoundGood(refVal_upperBoundGood);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("upperBoundMaybe"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("upperBoundMaybe")));
        if(!fieldValue.is_null())
        {
            double refVal_upperBoundMaybe;
            ok &= ModelBase::fromJson(fieldValue, refVal_upperBoundMaybe);
            setUpperBoundMaybe(refVal_upperBoundMaybe);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("value"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("value")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_value;
            ok &= ModelBase::fromJson(fieldValue, refVal_value);
            setValue(refVal_value);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("valueInt"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("valueInt")));
        if(!fieldValue.is_null())
        {
            double refVal_valueInt;
            ok &= ModelBase::fromJson(fieldValue, refVal_valueInt);
            setValueInt(refVal_valueInt);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("label"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("label")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_label;
            ok &= ModelBase::fromJson(fieldValue, refVal_label);
            setLabel(refVal_label);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("extraValue"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("extraValue")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_extraValue;
            ok &= ModelBase::fromJson(fieldValue, refVal_extraValue);
            setExtraValue(refVal_extraValue);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("extraLabel"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("extraLabel")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_extraLabel;
            ok &= ModelBase::fromJson(fieldValue, refVal_extraLabel);
            setExtraLabel(refVal_extraLabel);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("state"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("state")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<StatusState> refVal_state;
            ok &= ModelBase::fromJson(fieldValue, refVal_state);
            setState(refVal_state);
        }
    }
    
    applyMinMaxConstraints();
    return ok;
}

void StatusInfo::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_UpperBoundGoodIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("upperBoundGood")), m_UpperBoundGood));
    }
    if(m_UpperBoundMaybeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("upperBoundMaybe")), m_UpperBoundMaybe));
    }
    if(m_ValueIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("value")), m_Value));
    }
    if(m_ValueIntIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("valueInt")), m_ValueInt));
    }
    if(m_LabelIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("label")), m_Label));
    }
    if(m_ExtraValueIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("extraValue")), m_ExtraValue));
    }
    if(m_ExtraLabelIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("extraLabel")), m_ExtraLabel));
    }
    if(m_StateIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("state")), m_State));
    }
}

bool StatusInfo::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("upperBoundGood"))))
    {
        double refVal_upperBoundGood;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("upperBoundGood"))), refVal_upperBoundGood );
        setUpperBoundGood(refVal_upperBoundGood);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("upperBoundMaybe"))))
    {
        double refVal_upperBoundMaybe;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("upperBoundMaybe"))), refVal_upperBoundMaybe );
        setUpperBoundMaybe(refVal_upperBoundMaybe);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("value"))))
    {
        utility::string_t refVal_value;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("value"))), refVal_value );
        setValue(refVal_value);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("valueInt"))))
    {
        double refVal_valueInt;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("valueInt"))), refVal_valueInt );
        setValueInt(refVal_valueInt);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("label"))))
    {
        utility::string_t refVal_label;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("label"))), refVal_label );
        setLabel(refVal_label);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("extraValue"))))
    {
        utility::string_t refVal_extraValue;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("extraValue"))), refVal_extraValue );
        setExtraValue(refVal_extraValue);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("extraLabel"))))
    {
        utility::string_t refVal_extraLabel;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("extraLabel"))), refVal_extraLabel );
        setExtraLabel(refVal_extraLabel);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("state"))))
    {
        std::shared_ptr<StatusState> refVal_state;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("state"))), refVal_state );
        setState(refVal_state);
    }
    
    applyMinMaxConstraints();
    return ok;
}

double StatusInfo::getUpperBoundGood() const
{
    return m_UpperBoundGood;
}

void StatusInfo::setUpperBoundGood(double value)
{
	double v = value;
    m_UpperBoundGood = v;
    m_UpperBoundGoodIsSet = true;
}

bool StatusInfo::upperBoundGoodIsSet() const
{
    return m_UpperBoundGoodIsSet;
}

void StatusInfo::unsetUpperBoundGood()
{
    m_UpperBoundGoodIsSet = false;
}



double StatusInfo::getUpperBoundMaybe() const
{
    return m_UpperBoundMaybe;
}

void StatusInfo::setUpperBoundMaybe(double value)
{
	double v = value;
    m_UpperBoundMaybe = v;
    m_UpperBoundMaybeIsSet = true;
}

bool StatusInfo::upperBoundMaybeIsSet() const
{
    return m_UpperBoundMaybeIsSet;
}

void StatusInfo::unsetUpperBoundMaybe()
{
    m_UpperBoundMaybeIsSet = false;
}



utility::string_t StatusInfo::getValue() const
{
    return m_Value;
}

void StatusInfo::setValue(const utility::string_t& value)
{
	utility::string_t v = value;
    m_Value = v;
    m_ValueIsSet = true;
}

bool StatusInfo::valueIsSet() const
{
    return m_ValueIsSet;
}

void StatusInfo::unsetValue()
{
    m_ValueIsSet = false;
}



double StatusInfo::getValueInt() const
{
    return m_ValueInt;
}

void StatusInfo::setValueInt(double value)
{
	double v = value;
    m_ValueInt = v;
    m_ValueIntIsSet = true;
}

bool StatusInfo::valueIntIsSet() const
{
    return m_ValueIntIsSet;
}

void StatusInfo::unsetValueInt()
{
    m_ValueIntIsSet = false;
}



utility::string_t StatusInfo::getLabel() const
{
    return m_Label;
}

void StatusInfo::setLabel(const utility::string_t& value)
{
	utility::string_t v = value;
    m_Label = v;
    m_LabelIsSet = true;
}

bool StatusInfo::labelIsSet() const
{
    return m_LabelIsSet;
}

void StatusInfo::unsetLabel()
{
    m_LabelIsSet = false;
}



utility::string_t StatusInfo::getExtraValue() const
{
    return m_ExtraValue;
}

void StatusInfo::setExtraValue(const utility::string_t& value)
{
	utility::string_t v = value;
    m_ExtraValue = v;
    m_ExtraValueIsSet = true;
}

bool StatusInfo::extraValueIsSet() const
{
    return m_ExtraValueIsSet;
}

void StatusInfo::unsetExtraValue()
{
    m_ExtraValueIsSet = false;
}



utility::string_t StatusInfo::getExtraLabel() const
{
    return m_ExtraLabel;
}

void StatusInfo::setExtraLabel(const utility::string_t& value)
{
	utility::string_t v = value;
    m_ExtraLabel = v;
    m_ExtraLabelIsSet = true;
}

bool StatusInfo::extraLabelIsSet() const
{
    return m_ExtraLabelIsSet;
}

void StatusInfo::unsetExtraLabel()
{
    m_ExtraLabelIsSet = false;
}



std::shared_ptr<StatusState> StatusInfo::getState() const
{
    return m_State;
}

void StatusInfo::setState(const std::shared_ptr<StatusState>& value)
{
	std::shared_ptr<StatusState> v = value;
    m_State = v;
    m_StateIsSet = true;
}

bool StatusInfo::stateIsSet() const
{
    return m_StateIsSet;
}

void StatusInfo::unsetState()
{
    m_StateIsSet = false;
}


}
}
}
}


