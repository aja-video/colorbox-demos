/**
 * OpenAPI ColorBox
 * This is a REST API for the AJA ColorBox product.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@aja.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.4.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 * Copyright (C) 2020-2022 AJA Video Systems, Inc.  All rights reserved.
 */



#include "FrameStore.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




FrameStore::FrameStore()
{
    m_Enabled = false;
    m_EnabledIsSet = false;
    m_Dynamic = false;
    m_DynamicIsSet = false;
    m_ImageName = utility::conversions::to_string_t("");
    m_ImageNameIsSet = false;
    m_TimecodeAppended = false;
    m_TimecodeAppendedIsSet = false;
    m_FileTypeIsSet = false;
    m_LibraryEntry = 0;
    m_LibraryEntryIsSet = false;
    m_FormatIsSet = false;
    m_ConvertIsSet = false;
    m_RgbRangeIsSet = false;
}

FrameStore::~FrameStore()
{
}

void FrameStore::validate()
{
    // TODO: implement validation
}

bool FrameStore::applyMinMaxConstraints()
{
	bool anyMinMaxValueChanged = false;
	if (imageNameIsSet())
	{
		bool imageNameChanged = false;
		utility::string_t v = getImageName();
		if (imageNameChanged) { setImageName(v); anyMinMaxValueChanged = true; }
	}
	if (libraryEntryIsSet())
	{
		bool libraryEntryChanged = false;
		int32_t v = getLibraryEntry();
		if (libraryEntryChanged) { setLibraryEntry(v); anyMinMaxValueChanged = true; }
	}
	return anyMinMaxValueChanged;
}

web::json::value FrameStore::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_EnabledIsSet)
    {
        val[utility::conversions::to_string_t(U("enabled"))] = ModelBase::toJson(m_Enabled);
    }
    if(m_DynamicIsSet)
    {
        val[utility::conversions::to_string_t(U("dynamic"))] = ModelBase::toJson(m_Dynamic);
    }
    if(m_ImageNameIsSet)
    {
        val[utility::conversions::to_string_t(U("imageName"))] = ModelBase::toJson(m_ImageName);
    }
    if(m_TimecodeAppendedIsSet)
    {
        val[utility::conversions::to_string_t(U("timecodeAppended"))] = ModelBase::toJson(m_TimecodeAppended);
    }
    if(m_FileTypeIsSet)
    {
        val[utility::conversions::to_string_t(U("fileType"))] = ModelBase::toJson(m_FileType);
    }
    if(m_LibraryEntryIsSet)
    {
        val[utility::conversions::to_string_t(U("libraryEntry"))] = ModelBase::toJson(m_LibraryEntry);
    }
    if(m_FormatIsSet)
    {
        val[utility::conversions::to_string_t(U("format"))] = ModelBase::toJson(m_Format);
    }
    if(m_ConvertIsSet)
    {
        val[utility::conversions::to_string_t(U("convert"))] = ModelBase::toJson(m_Convert);
    }
    if(m_RgbRangeIsSet)
    {
        val[utility::conversions::to_string_t(U("rgbRange"))] = ModelBase::toJson(m_RgbRange);
    }

    return val;
}

bool FrameStore::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("enabled"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("enabled")));
        if(!fieldValue.is_null())
        {
            bool refVal_enabled;
            ok &= ModelBase::fromJson(fieldValue, refVal_enabled);
            setEnabled(refVal_enabled);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("dynamic"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("dynamic")));
        if(!fieldValue.is_null())
        {
            bool refVal_dynamic;
            ok &= ModelBase::fromJson(fieldValue, refVal_dynamic);
            setDynamic(refVal_dynamic);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("imageName"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("imageName")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_imageName;
            ok &= ModelBase::fromJson(fieldValue, refVal_imageName);
            setImageName(refVal_imageName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("timecodeAppended"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("timecodeAppended")));
        if(!fieldValue.is_null())
        {
            bool refVal_timecodeAppended;
            ok &= ModelBase::fromJson(fieldValue, refVal_timecodeAppended);
            setTimecodeAppended(refVal_timecodeAppended);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("fileType"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("fileType")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<FileTypeChoice> refVal_fileType;
            ok &= ModelBase::fromJson(fieldValue, refVal_fileType);
            setFileType(refVal_fileType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("libraryEntry"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("libraryEntry")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_libraryEntry;
            ok &= ModelBase::fromJson(fieldValue, refVal_libraryEntry);
            setLibraryEntry(refVal_libraryEntry);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("format"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("format")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<VideoFormat> refVal_format;
            ok &= ModelBase::fromJson(fieldValue, refVal_format);
            setFormat(refVal_format);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("convert"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("convert")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<VideoConvertChoice> refVal_convert;
            ok &= ModelBase::fromJson(fieldValue, refVal_convert);
            setConvert(refVal_convert);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("rgbRange"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("rgbRange")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<RgbRange> refVal_rgbRange;
            ok &= ModelBase::fromJson(fieldValue, refVal_rgbRange);
            setRgbRange(refVal_rgbRange);
        }
    }
    
    applyMinMaxConstraints();
    return ok;
}

void FrameStore::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_EnabledIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("enabled")), m_Enabled));
    }
    if(m_DynamicIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("dynamic")), m_Dynamic));
    }
    if(m_ImageNameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("imageName")), m_ImageName));
    }
    if(m_TimecodeAppendedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("timecodeAppended")), m_TimecodeAppended));
    }
    if(m_FileTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("fileType")), m_FileType));
    }
    if(m_LibraryEntryIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("libraryEntry")), m_LibraryEntry));
    }
    if(m_FormatIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("format")), m_Format));
    }
    if(m_ConvertIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("convert")), m_Convert));
    }
    if(m_RgbRangeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("rgbRange")), m_RgbRange));
    }
}

bool FrameStore::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("enabled"))))
    {
        bool refVal_enabled;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("enabled"))), refVal_enabled );
        setEnabled(refVal_enabled);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("dynamic"))))
    {
        bool refVal_dynamic;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("dynamic"))), refVal_dynamic );
        setDynamic(refVal_dynamic);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("imageName"))))
    {
        utility::string_t refVal_imageName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("imageName"))), refVal_imageName );
        setImageName(refVal_imageName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("timecodeAppended"))))
    {
        bool refVal_timecodeAppended;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("timecodeAppended"))), refVal_timecodeAppended );
        setTimecodeAppended(refVal_timecodeAppended);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("fileType"))))
    {
        std::shared_ptr<FileTypeChoice> refVal_fileType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("fileType"))), refVal_fileType );
        setFileType(refVal_fileType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("libraryEntry"))))
    {
        int32_t refVal_libraryEntry;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("libraryEntry"))), refVal_libraryEntry );
        setLibraryEntry(refVal_libraryEntry);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("format"))))
    {
        std::shared_ptr<VideoFormat> refVal_format;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("format"))), refVal_format );
        setFormat(refVal_format);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("convert"))))
    {
        std::shared_ptr<VideoConvertChoice> refVal_convert;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("convert"))), refVal_convert );
        setConvert(refVal_convert);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("rgbRange"))))
    {
        std::shared_ptr<RgbRange> refVal_rgbRange;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("rgbRange"))), refVal_rgbRange );
        setRgbRange(refVal_rgbRange);
    }
    
    applyMinMaxConstraints();
    return ok;
}

bool FrameStore::isEnabled() const
{
    return m_Enabled;
}

void FrameStore::setEnabled(bool value)
{
	bool v = value;
    m_Enabled = v;
    m_EnabledIsSet = true;
}

bool FrameStore::enabledIsSet() const
{
    return m_EnabledIsSet;
}

void FrameStore::unsetEnabled()
{
    m_EnabledIsSet = false;
}


bool FrameStore::isDynamic() const
{
    return m_Dynamic;
}

void FrameStore::setDynamic(bool value)
{
	bool v = value;
    m_Dynamic = v;
    m_DynamicIsSet = true;
}

bool FrameStore::dynamicIsSet() const
{
    return m_DynamicIsSet;
}

void FrameStore::unsetDynamic()
{
    m_DynamicIsSet = false;
}


utility::string_t FrameStore::getImageName() const
{
    return m_ImageName;
}

void FrameStore::setImageName(const utility::string_t& value)
{
	utility::string_t v = value;
    m_ImageName = v;
    m_ImageNameIsSet = true;
}

bool FrameStore::imageNameIsSet() const
{
    return m_ImageNameIsSet;
}

void FrameStore::unsetImageName()
{
    m_ImageNameIsSet = false;
}



bool FrameStore::isTimecodeAppended() const
{
    return m_TimecodeAppended;
}

void FrameStore::setTimecodeAppended(bool value)
{
	bool v = value;
    m_TimecodeAppended = v;
    m_TimecodeAppendedIsSet = true;
}

bool FrameStore::timecodeAppendedIsSet() const
{
    return m_TimecodeAppendedIsSet;
}

void FrameStore::unsetTimecodeAppended()
{
    m_TimecodeAppendedIsSet = false;
}


std::shared_ptr<FileTypeChoice> FrameStore::getFileType() const
{
    return m_FileType;
}

void FrameStore::setFileType(const std::shared_ptr<FileTypeChoice>& value)
{
	std::shared_ptr<FileTypeChoice> v = value;
    m_FileType = v;
    m_FileTypeIsSet = true;
}

bool FrameStore::fileTypeIsSet() const
{
    return m_FileTypeIsSet;
}

void FrameStore::unsetFileType()
{
    m_FileTypeIsSet = false;
}


int32_t FrameStore::getLibraryEntry() const
{
    return m_LibraryEntry;
}

void FrameStore::setLibraryEntry(int32_t value)
{
	int32_t v = value;
    m_LibraryEntry = v;
    m_LibraryEntryIsSet = true;
}

bool FrameStore::libraryEntryIsSet() const
{
    return m_LibraryEntryIsSet;
}

void FrameStore::unsetLibraryEntry()
{
    m_LibraryEntryIsSet = false;
}



std::shared_ptr<VideoFormat> FrameStore::getFormat() const
{
    return m_Format;
}

void FrameStore::setFormat(const std::shared_ptr<VideoFormat>& value)
{
	std::shared_ptr<VideoFormat> v = value;
    m_Format = v;
    m_FormatIsSet = true;
}

bool FrameStore::formatIsSet() const
{
    return m_FormatIsSet;
}

void FrameStore::unsetFormat()
{
    m_FormatIsSet = false;
}


std::shared_ptr<VideoConvertChoice> FrameStore::getConvert() const
{
    return m_Convert;
}

void FrameStore::setConvert(const std::shared_ptr<VideoConvertChoice>& value)
{
	std::shared_ptr<VideoConvertChoice> v = value;
    m_Convert = v;
    m_ConvertIsSet = true;
}

bool FrameStore::convertIsSet() const
{
    return m_ConvertIsSet;
}

void FrameStore::unsetConvert()
{
    m_ConvertIsSet = false;
}


std::shared_ptr<RgbRange> FrameStore::getRgbRange() const
{
    return m_RgbRange;
}

void FrameStore::setRgbRange(const std::shared_ptr<RgbRange>& value)
{
	std::shared_ptr<RgbRange> v = value;
    m_RgbRange = v;
    m_RgbRangeIsSet = true;
}

bool FrameStore::rgbRangeIsSet() const
{
    return m_RgbRangeIsSet;
}

void FrameStore::unsetRgbRange()
{
    m_RgbRangeIsSet = false;
}


}
}
}
}


