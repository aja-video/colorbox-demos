/**
 * OpenAPI ColorBox
 * This is a REST API for the AJA ColorBox product.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@aja.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.4.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 * Copyright (C) 2020-2022 AJA Video Systems Inc.  All rights reserved.
 */



#include "SDI.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




SDI::SDI()
{
    m_ColorSpaceIsSet = false;
    m_RgbRangeIsSet = false;
    m_BitDepthIsSet = false;
    m_ScanModeIsSet = false;
    m_SdiMode3gIsSet = false;
    m_ColorimetryIsSet = false;
    m_TransferIsSet = false;
    m_FormatIsSet = false;
}

SDI::~SDI()
{
}

void SDI::validate()
{
    // TODO: implement validation
}

bool SDI::applyMinMaxConstraints()
{
	bool anyMinMaxValueChanged = false;
	return anyMinMaxValueChanged;
}

web::json::value SDI::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_ColorSpaceIsSet)
    {
        val[utility::conversions::to_string_t(U("colorSpace"))] = ModelBase::toJson(m_ColorSpace);
    }
    if(m_RgbRangeIsSet)
    {
        val[utility::conversions::to_string_t(U("rgbRange"))] = ModelBase::toJson(m_RgbRange);
    }
    if(m_BitDepthIsSet)
    {
        val[utility::conversions::to_string_t(U("bitDepth"))] = ModelBase::toJson(m_BitDepth);
    }
    if(m_ScanModeIsSet)
    {
        val[utility::conversions::to_string_t(U("scanMode"))] = ModelBase::toJson(m_ScanMode);
    }
    if(m_SdiMode3gIsSet)
    {
        val[utility::conversions::to_string_t(U("sdiMode3g"))] = ModelBase::toJson(m_SdiMode3g);
    }
    if(m_ColorimetryIsSet)
    {
        val[utility::conversions::to_string_t(U("colorimetry"))] = ModelBase::toJson(m_Colorimetry);
    }
    if(m_TransferIsSet)
    {
        val[utility::conversions::to_string_t(U("transfer"))] = ModelBase::toJson(m_Transfer);
    }
    if(m_FormatIsSet)
    {
        val[utility::conversions::to_string_t(U("format"))] = ModelBase::toJson(m_Format);
    }

    return val;
}

bool SDI::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("colorSpace"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("colorSpace")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ColorSpace> refVal_colorSpace;
            ok &= ModelBase::fromJson(fieldValue, refVal_colorSpace);
            setColorSpace(refVal_colorSpace);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("rgbRange"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("rgbRange")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<RgbRange> refVal_rgbRange;
            ok &= ModelBase::fromJson(fieldValue, refVal_rgbRange);
            setRgbRange(refVal_rgbRange);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("bitDepth"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("bitDepth")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<BitDepth> refVal_bitDepth;
            ok &= ModelBase::fromJson(fieldValue, refVal_bitDepth);
            setBitDepth(refVal_bitDepth);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("scanMode"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("scanMode")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ScanMode> refVal_scanMode;
            ok &= ModelBase::fromJson(fieldValue, refVal_scanMode);
            setScanMode(refVal_scanMode);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sdiMode3g"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sdiMode3g")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<SdiMode3g> refVal_sdiMode3g;
            ok &= ModelBase::fromJson(fieldValue, refVal_sdiMode3g);
            setSdiMode3g(refVal_sdiMode3g);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("colorimetry"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("colorimetry")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Colorimetry> refVal_colorimetry;
            ok &= ModelBase::fromJson(fieldValue, refVal_colorimetry);
            setColorimetry(refVal_colorimetry);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("transfer"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("transfer")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Transfer> refVal_transfer;
            ok &= ModelBase::fromJson(fieldValue, refVal_transfer);
            setTransfer(refVal_transfer);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("format"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("format")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<VideoFormat> refVal_format;
            ok &= ModelBase::fromJson(fieldValue, refVal_format);
            setFormat(refVal_format);
        }
    }
    
    applyMinMaxConstraints();
    return ok;
}

void SDI::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_ColorSpaceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("colorSpace")), m_ColorSpace));
    }
    if(m_RgbRangeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("rgbRange")), m_RgbRange));
    }
    if(m_BitDepthIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("bitDepth")), m_BitDepth));
    }
    if(m_ScanModeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("scanMode")), m_ScanMode));
    }
    if(m_SdiMode3gIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sdiMode3g")), m_SdiMode3g));
    }
    if(m_ColorimetryIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("colorimetry")), m_Colorimetry));
    }
    if(m_TransferIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("transfer")), m_Transfer));
    }
    if(m_FormatIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("format")), m_Format));
    }
}

bool SDI::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("colorSpace"))))
    {
        std::shared_ptr<ColorSpace> refVal_colorSpace;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("colorSpace"))), refVal_colorSpace );
        setColorSpace(refVal_colorSpace);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("rgbRange"))))
    {
        std::shared_ptr<RgbRange> refVal_rgbRange;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("rgbRange"))), refVal_rgbRange );
        setRgbRange(refVal_rgbRange);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("bitDepth"))))
    {
        std::shared_ptr<BitDepth> refVal_bitDepth;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("bitDepth"))), refVal_bitDepth );
        setBitDepth(refVal_bitDepth);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("scanMode"))))
    {
        std::shared_ptr<ScanMode> refVal_scanMode;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("scanMode"))), refVal_scanMode );
        setScanMode(refVal_scanMode);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sdiMode3g"))))
    {
        std::shared_ptr<SdiMode3g> refVal_sdiMode3g;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sdiMode3g"))), refVal_sdiMode3g );
        setSdiMode3g(refVal_sdiMode3g);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("colorimetry"))))
    {
        std::shared_ptr<Colorimetry> refVal_colorimetry;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("colorimetry"))), refVal_colorimetry );
        setColorimetry(refVal_colorimetry);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("transfer"))))
    {
        std::shared_ptr<Transfer> refVal_transfer;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("transfer"))), refVal_transfer );
        setTransfer(refVal_transfer);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("format"))))
    {
        std::shared_ptr<VideoFormat> refVal_format;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("format"))), refVal_format );
        setFormat(refVal_format);
    }
    
    applyMinMaxConstraints();
    return ok;
}

std::shared_ptr<ColorSpace> SDI::getColorSpace() const
{
    return m_ColorSpace;
}

void SDI::setColorSpace(const std::shared_ptr<ColorSpace>& value)
{
	std::shared_ptr<ColorSpace> v = value;
    m_ColorSpace = v;
    m_ColorSpaceIsSet = true;
}

bool SDI::colorSpaceIsSet() const
{
    return m_ColorSpaceIsSet;
}

void SDI::unsetColorSpace()
{
    m_ColorSpaceIsSet = false;
}


std::shared_ptr<RgbRange> SDI::getRgbRange() const
{
    return m_RgbRange;
}

void SDI::setRgbRange(const std::shared_ptr<RgbRange>& value)
{
	std::shared_ptr<RgbRange> v = value;
    m_RgbRange = v;
    m_RgbRangeIsSet = true;
}

bool SDI::rgbRangeIsSet() const
{
    return m_RgbRangeIsSet;
}

void SDI::unsetRgbRange()
{
    m_RgbRangeIsSet = false;
}


std::shared_ptr<BitDepth> SDI::getBitDepth() const
{
    return m_BitDepth;
}

void SDI::setBitDepth(const std::shared_ptr<BitDepth>& value)
{
	std::shared_ptr<BitDepth> v = value;
    m_BitDepth = v;
    m_BitDepthIsSet = true;
}

bool SDI::bitDepthIsSet() const
{
    return m_BitDepthIsSet;
}

void SDI::unsetBitDepth()
{
    m_BitDepthIsSet = false;
}


std::shared_ptr<ScanMode> SDI::getScanMode() const
{
    return m_ScanMode;
}

void SDI::setScanMode(const std::shared_ptr<ScanMode>& value)
{
	std::shared_ptr<ScanMode> v = value;
    m_ScanMode = v;
    m_ScanModeIsSet = true;
}

bool SDI::scanModeIsSet() const
{
    return m_ScanModeIsSet;
}

void SDI::unsetScanMode()
{
    m_ScanModeIsSet = false;
}


std::shared_ptr<SdiMode3g> SDI::getSdiMode3g() const
{
    return m_SdiMode3g;
}

void SDI::setSdiMode3g(const std::shared_ptr<SdiMode3g>& value)
{
	std::shared_ptr<SdiMode3g> v = value;
    m_SdiMode3g = v;
    m_SdiMode3gIsSet = true;
}

bool SDI::sdiMode3gIsSet() const
{
    return m_SdiMode3gIsSet;
}

void SDI::unsetSdiMode3g()
{
    m_SdiMode3gIsSet = false;
}


std::shared_ptr<Colorimetry> SDI::getColorimetry() const
{
    return m_Colorimetry;
}

void SDI::setColorimetry(const std::shared_ptr<Colorimetry>& value)
{
	std::shared_ptr<Colorimetry> v = value;
    m_Colorimetry = v;
    m_ColorimetryIsSet = true;
}

bool SDI::colorimetryIsSet() const
{
    return m_ColorimetryIsSet;
}

void SDI::unsetColorimetry()
{
    m_ColorimetryIsSet = false;
}


std::shared_ptr<Transfer> SDI::getTransfer() const
{
    return m_Transfer;
}

void SDI::setTransfer(const std::shared_ptr<Transfer>& value)
{
	std::shared_ptr<Transfer> v = value;
    m_Transfer = v;
    m_TransferIsSet = true;
}

bool SDI::transferIsSet() const
{
    return m_TransferIsSet;
}

void SDI::unsetTransfer()
{
    m_TransferIsSet = false;
}


std::shared_ptr<VideoFormat> SDI::getFormat() const
{
    return m_Format;
}

void SDI::setFormat(const std::shared_ptr<VideoFormat>& value)
{
	std::shared_ptr<VideoFormat> v = value;
    m_Format = v;
    m_FormatIsSet = true;
}

bool SDI::formatIsSet() const
{
    return m_FormatIsSet;
}

void SDI::unsetFormat()
{
    m_FormatIsSet = false;
}


}
}
}
}


