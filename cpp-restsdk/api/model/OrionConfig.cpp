/**
 * OpenAPI ColorBox
 * This is a REST API for the AJA ColorBox product.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@aja.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.4.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 * Copyright (C) 2020-2022 AJA Video Systems Inc.  All rights reserved.
 */



#include "OrionConfig.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




OrionConfig::OrionConfig()
{
    m_Enabled = false;
    m_EnabledIsSet = false;
    m_GammaComp = false;
    m_GammaCompIsSet = false;
    m_ConversionIsSet = false;
    m_ModeIsSet = false;
    m_MethodIsSet = false;
    m_SourceRangeIsSet = false;
    m_HdrRef = 0.0;
    m_HdrRefIsSet = false;
    m_SdrRef = 0.0;
    m_SdrRefIsSet = false;
    m_HdrPeak = 0;
    m_HdrPeakIsSet = false;
    m_SdrEotfIsSet = false;
    m_PreKnee = 0.0;
    m_PreKneeIsSet = false;
    m_PreAmount = 0.0;
    m_PreAmountIsSet = false;
    m_PostKnee = 0.0;
    m_PostKneeIsSet = false;
    m_PostAmount = 0.0;
    m_PostAmountIsSet = false;
    m_ClampingIsSet = false;
    m_ImplementationIsSet = false;
}

OrionConfig::~OrionConfig()
{
}

void OrionConfig::validate()
{
    // TODO: implement validation
}

bool OrionConfig::applyMinMaxConstraints()
{
	bool anyMinMaxValueChanged = false;
	if (hdrRefIsSet())
	{
		bool hdrRefChanged = false;
		double v = getHdrRef();
		double min = hdrRefMin();
		double max = hdrRefMax();
		if (v < min) { v = min; hdrRefChanged = true; }
		if (v > max) { v = max; hdrRefChanged = true; }
		if (hdrRefChanged) { setHdrRef(v); anyMinMaxValueChanged = true; }
	}
	if (sdrRefIsSet())
	{
		bool sdrRefChanged = false;
		double v = getSdrRef();
		double min = sdrRefMin();
		double max = sdrRefMax();
		if (v < min) { v = min; sdrRefChanged = true; }
		if (v > max) { v = max; sdrRefChanged = true; }
		if (sdrRefChanged) { setSdrRef(v); anyMinMaxValueChanged = true; }
	}
	if (hdrPeakIsSet())
	{
		bool hdrPeakChanged = false;
		int32_t v = getHdrPeak();
		int32_t min = hdrPeakMin();
		int32_t max = hdrPeakMax();
		if (v < min) { v = min; hdrPeakChanged = true; }
		if (v > max) { v = max; hdrPeakChanged = true; }
		if (hdrPeakChanged) { setHdrPeak(v); anyMinMaxValueChanged = true; }
	}
	if (preKneeIsSet())
	{
		bool preKneeChanged = false;
		double v = getPreKnee();
		double min = preKneeMin();
		double max = preKneeMax();
		if (v < min) { v = min; preKneeChanged = true; }
		if (v > max) { v = max; preKneeChanged = true; }
		if (preKneeChanged) { setPreKnee(v); anyMinMaxValueChanged = true; }
	}
	if (preAmountIsSet())
	{
		bool preAmountChanged = false;
		double v = getPreAmount();
		double min = preAmountMin();
		double max = preAmountMax();
		if (v < min) { v = min; preAmountChanged = true; }
		if (v > max) { v = max; preAmountChanged = true; }
		if (preAmountChanged) { setPreAmount(v); anyMinMaxValueChanged = true; }
	}
	if (postKneeIsSet())
	{
		bool postKneeChanged = false;
		double v = getPostKnee();
		double min = postKneeMin();
		double max = postKneeMax();
		if (v < min) { v = min; postKneeChanged = true; }
		if (v > max) { v = max; postKneeChanged = true; }
		if (postKneeChanged) { setPostKnee(v); anyMinMaxValueChanged = true; }
	}
	if (postAmountIsSet())
	{
		bool postAmountChanged = false;
		double v = getPostAmount();
		double min = postAmountMin();
		double max = postAmountMax();
		if (v < min) { v = min; postAmountChanged = true; }
		if (v > max) { v = max; postAmountChanged = true; }
		if (postAmountChanged) { setPostAmount(v); anyMinMaxValueChanged = true; }
	}
	return anyMinMaxValueChanged;
}

web::json::value OrionConfig::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_EnabledIsSet)
    {
        val[utility::conversions::to_string_t(U("enabled"))] = ModelBase::toJson(m_Enabled);
    }
    if(m_GammaCompIsSet)
    {
        val[utility::conversions::to_string_t(U("gammaComp"))] = ModelBase::toJson(m_GammaComp);
    }
    if(m_ConversionIsSet)
    {
        val[utility::conversions::to_string_t(U("conversion"))] = ModelBase::toJson(m_Conversion);
    }
    if(m_ModeIsSet)
    {
        val[utility::conversions::to_string_t(U("mode"))] = ModelBase::toJson(m_Mode);
    }
    if(m_MethodIsSet)
    {
        val[utility::conversions::to_string_t(U("method"))] = ModelBase::toJson(m_Method);
    }
    if(m_SourceRangeIsSet)
    {
        val[utility::conversions::to_string_t(U("sourceRange"))] = ModelBase::toJson(m_SourceRange);
    }
    if(m_HdrRefIsSet)
    {
        val[utility::conversions::to_string_t(U("hdrRef"))] = ModelBase::toJson(m_HdrRef);
    }
    if(m_SdrRefIsSet)
    {
        val[utility::conversions::to_string_t(U("sdrRef"))] = ModelBase::toJson(m_SdrRef);
    }
    if(m_HdrPeakIsSet)
    {
        val[utility::conversions::to_string_t(U("hdrPeak"))] = ModelBase::toJson(m_HdrPeak);
    }
    if(m_SdrEotfIsSet)
    {
        val[utility::conversions::to_string_t(U("sdrEotf"))] = ModelBase::toJson(m_SdrEotf);
    }
    if(m_PreKneeIsSet)
    {
        val[utility::conversions::to_string_t(U("preKnee"))] = ModelBase::toJson(m_PreKnee);
    }
    if(m_PreAmountIsSet)
    {
        val[utility::conversions::to_string_t(U("preAmount"))] = ModelBase::toJson(m_PreAmount);
    }
    if(m_PostKneeIsSet)
    {
        val[utility::conversions::to_string_t(U("postKnee"))] = ModelBase::toJson(m_PostKnee);
    }
    if(m_PostAmountIsSet)
    {
        val[utility::conversions::to_string_t(U("postAmount"))] = ModelBase::toJson(m_PostAmount);
    }
    if(m_ClampingIsSet)
    {
        val[utility::conversions::to_string_t(U("clamping"))] = ModelBase::toJson(m_Clamping);
    }
    if(m_ImplementationIsSet)
    {
        val[utility::conversions::to_string_t(U("implementation"))] = ModelBase::toJson(m_Implementation);
    }

    return val;
}

bool OrionConfig::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("enabled"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("enabled")));
        if(!fieldValue.is_null())
        {
            bool refVal_enabled;
            ok &= ModelBase::fromJson(fieldValue, refVal_enabled);
            setEnabled(refVal_enabled);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("gammaComp"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("gammaComp")));
        if(!fieldValue.is_null())
        {
            bool refVal_gammaComp;
            ok &= ModelBase::fromJson(fieldValue, refVal_gammaComp);
            setGammaComp(refVal_gammaComp);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("conversion"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("conversion")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<OrionConversion> refVal_conversion;
            ok &= ModelBase::fromJson(fieldValue, refVal_conversion);
            setConversion(refVal_conversion);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("mode"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("mode")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<OrionMode> refVal_mode;
            ok &= ModelBase::fromJson(fieldValue, refVal_mode);
            setMode(refVal_mode);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("method"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("method")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<OrionMethod> refVal_method;
            ok &= ModelBase::fromJson(fieldValue, refVal_method);
            setMethod(refVal_method);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sourceRange"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sourceRange")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<OrionSourceRange> refVal_sourceRange;
            ok &= ModelBase::fromJson(fieldValue, refVal_sourceRange);
            setSourceRange(refVal_sourceRange);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("hdrRef"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("hdrRef")));
        if(!fieldValue.is_null())
        {
            double refVal_hdrRef;
            ok &= ModelBase::fromJson(fieldValue, refVal_hdrRef);
            setHdrRef(refVal_hdrRef);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sdrRef"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sdrRef")));
        if(!fieldValue.is_null())
        {
            double refVal_sdrRef;
            ok &= ModelBase::fromJson(fieldValue, refVal_sdrRef);
            setSdrRef(refVal_sdrRef);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("hdrPeak"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("hdrPeak")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_hdrPeak;
            ok &= ModelBase::fromJson(fieldValue, refVal_hdrPeak);
            setHdrPeak(refVal_hdrPeak);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sdrEotf"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sdrEotf")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<OrionSdrEotf> refVal_sdrEotf;
            ok &= ModelBase::fromJson(fieldValue, refVal_sdrEotf);
            setSdrEotf(refVal_sdrEotf);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("preKnee"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("preKnee")));
        if(!fieldValue.is_null())
        {
            double refVal_preKnee;
            ok &= ModelBase::fromJson(fieldValue, refVal_preKnee);
            setPreKnee(refVal_preKnee);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("preAmount"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("preAmount")));
        if(!fieldValue.is_null())
        {
            double refVal_preAmount;
            ok &= ModelBase::fromJson(fieldValue, refVal_preAmount);
            setPreAmount(refVal_preAmount);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("postKnee"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("postKnee")));
        if(!fieldValue.is_null())
        {
            double refVal_postKnee;
            ok &= ModelBase::fromJson(fieldValue, refVal_postKnee);
            setPostKnee(refVal_postKnee);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("postAmount"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("postAmount")));
        if(!fieldValue.is_null())
        {
            double refVal_postAmount;
            ok &= ModelBase::fromJson(fieldValue, refVal_postAmount);
            setPostAmount(refVal_postAmount);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("clamping"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("clamping")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<OrionClamping> refVal_clamping;
            ok &= ModelBase::fromJson(fieldValue, refVal_clamping);
            setClamping(refVal_clamping);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("implementation"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("implementation")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<OrionImplementation> refVal_implementation;
            ok &= ModelBase::fromJson(fieldValue, refVal_implementation);
            setImplementation(refVal_implementation);
        }
    }
    
    applyMinMaxConstraints();
    return ok;
}

void OrionConfig::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_EnabledIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("enabled")), m_Enabled));
    }
    if(m_GammaCompIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("gammaComp")), m_GammaComp));
    }
    if(m_ConversionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("conversion")), m_Conversion));
    }
    if(m_ModeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("mode")), m_Mode));
    }
    if(m_MethodIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("method")), m_Method));
    }
    if(m_SourceRangeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sourceRange")), m_SourceRange));
    }
    if(m_HdrRefIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("hdrRef")), m_HdrRef));
    }
    if(m_SdrRefIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sdrRef")), m_SdrRef));
    }
    if(m_HdrPeakIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("hdrPeak")), m_HdrPeak));
    }
    if(m_SdrEotfIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sdrEotf")), m_SdrEotf));
    }
    if(m_PreKneeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("preKnee")), m_PreKnee));
    }
    if(m_PreAmountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("preAmount")), m_PreAmount));
    }
    if(m_PostKneeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("postKnee")), m_PostKnee));
    }
    if(m_PostAmountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("postAmount")), m_PostAmount));
    }
    if(m_ClampingIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("clamping")), m_Clamping));
    }
    if(m_ImplementationIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("implementation")), m_Implementation));
    }
}

bool OrionConfig::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("enabled"))))
    {
        bool refVal_enabled;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("enabled"))), refVal_enabled );
        setEnabled(refVal_enabled);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("gammaComp"))))
    {
        bool refVal_gammaComp;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("gammaComp"))), refVal_gammaComp );
        setGammaComp(refVal_gammaComp);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("conversion"))))
    {
        std::shared_ptr<OrionConversion> refVal_conversion;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("conversion"))), refVal_conversion );
        setConversion(refVal_conversion);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("mode"))))
    {
        std::shared_ptr<OrionMode> refVal_mode;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("mode"))), refVal_mode );
        setMode(refVal_mode);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("method"))))
    {
        std::shared_ptr<OrionMethod> refVal_method;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("method"))), refVal_method );
        setMethod(refVal_method);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sourceRange"))))
    {
        std::shared_ptr<OrionSourceRange> refVal_sourceRange;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sourceRange"))), refVal_sourceRange );
        setSourceRange(refVal_sourceRange);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("hdrRef"))))
    {
        double refVal_hdrRef;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("hdrRef"))), refVal_hdrRef );
        setHdrRef(refVal_hdrRef);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sdrRef"))))
    {
        double refVal_sdrRef;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sdrRef"))), refVal_sdrRef );
        setSdrRef(refVal_sdrRef);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("hdrPeak"))))
    {
        int32_t refVal_hdrPeak;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("hdrPeak"))), refVal_hdrPeak );
        setHdrPeak(refVal_hdrPeak);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sdrEotf"))))
    {
        std::shared_ptr<OrionSdrEotf> refVal_sdrEotf;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sdrEotf"))), refVal_sdrEotf );
        setSdrEotf(refVal_sdrEotf);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("preKnee"))))
    {
        double refVal_preKnee;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("preKnee"))), refVal_preKnee );
        setPreKnee(refVal_preKnee);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("preAmount"))))
    {
        double refVal_preAmount;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("preAmount"))), refVal_preAmount );
        setPreAmount(refVal_preAmount);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("postKnee"))))
    {
        double refVal_postKnee;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("postKnee"))), refVal_postKnee );
        setPostKnee(refVal_postKnee);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("postAmount"))))
    {
        double refVal_postAmount;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("postAmount"))), refVal_postAmount );
        setPostAmount(refVal_postAmount);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("clamping"))))
    {
        std::shared_ptr<OrionClamping> refVal_clamping;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("clamping"))), refVal_clamping );
        setClamping(refVal_clamping);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("implementation"))))
    {
        std::shared_ptr<OrionImplementation> refVal_implementation;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("implementation"))), refVal_implementation );
        setImplementation(refVal_implementation);
    }
    
    applyMinMaxConstraints();
    return ok;
}

bool OrionConfig::isEnabled() const
{
    return m_Enabled;
}

void OrionConfig::setEnabled(bool value)
{
	bool v = value;
    m_Enabled = v;
    m_EnabledIsSet = true;
}

bool OrionConfig::enabledIsSet() const
{
    return m_EnabledIsSet;
}

void OrionConfig::unsetEnabled()
{
    m_EnabledIsSet = false;
}


bool OrionConfig::isGammaComp() const
{
    return m_GammaComp;
}

void OrionConfig::setGammaComp(bool value)
{
	bool v = value;
    m_GammaComp = v;
    m_GammaCompIsSet = true;
}

bool OrionConfig::gammaCompIsSet() const
{
    return m_GammaCompIsSet;
}

void OrionConfig::unsetGammaComp()
{
    m_GammaCompIsSet = false;
}


std::shared_ptr<OrionConversion> OrionConfig::getConversion() const
{
    return m_Conversion;
}

void OrionConfig::setConversion(const std::shared_ptr<OrionConversion>& value)
{
	std::shared_ptr<OrionConversion> v = value;
    m_Conversion = v;
    m_ConversionIsSet = true;
}

bool OrionConfig::conversionIsSet() const
{
    return m_ConversionIsSet;
}

void OrionConfig::unsetConversion()
{
    m_ConversionIsSet = false;
}


std::shared_ptr<OrionMode> OrionConfig::getMode() const
{
    return m_Mode;
}

void OrionConfig::setMode(const std::shared_ptr<OrionMode>& value)
{
	std::shared_ptr<OrionMode> v = value;
    m_Mode = v;
    m_ModeIsSet = true;
}

bool OrionConfig::modeIsSet() const
{
    return m_ModeIsSet;
}

void OrionConfig::unsetMode()
{
    m_ModeIsSet = false;
}


std::shared_ptr<OrionMethod> OrionConfig::getMethod() const
{
    return m_Method;
}

void OrionConfig::setMethod(const std::shared_ptr<OrionMethod>& value)
{
	std::shared_ptr<OrionMethod> v = value;
    m_Method = v;
    m_MethodIsSet = true;
}

bool OrionConfig::methodIsSet() const
{
    return m_MethodIsSet;
}

void OrionConfig::unsetMethod()
{
    m_MethodIsSet = false;
}


std::shared_ptr<OrionSourceRange> OrionConfig::getSourceRange() const
{
    return m_SourceRange;
}

void OrionConfig::setSourceRange(const std::shared_ptr<OrionSourceRange>& value)
{
	std::shared_ptr<OrionSourceRange> v = value;
    m_SourceRange = v;
    m_SourceRangeIsSet = true;
}

bool OrionConfig::sourceRangeIsSet() const
{
    return m_SourceRangeIsSet;
}

void OrionConfig::unsetSourceRange()
{
    m_SourceRangeIsSet = false;
}


double OrionConfig::getHdrRef() const
{
    return m_HdrRef;
}

void OrionConfig::setHdrRef(double value)
{
	double v = value;
	double min = hdrRefMin();
	double max = hdrRefMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_HdrRef = v;
    m_HdrRefIsSet = true;
}

bool OrionConfig::hdrRefIsSet() const
{
    return m_HdrRefIsSet;
}

void OrionConfig::unsetHdrRef()
{
    m_HdrRefIsSet = false;
}

double OrionConfig::hdrRefMin() const {
	return 1.0;
}

double OrionConfig::hdrRefMax() const {
	return 109.0;
}

double OrionConfig::getSdrRef() const
{
    return m_SdrRef;
}

void OrionConfig::setSdrRef(double value)
{
	double v = value;
	double min = sdrRefMin();
	double max = sdrRefMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_SdrRef = v;
    m_SdrRefIsSet = true;
}

bool OrionConfig::sdrRefIsSet() const
{
    return m_SdrRefIsSet;
}

void OrionConfig::unsetSdrRef()
{
    m_SdrRefIsSet = false;
}

double OrionConfig::sdrRefMin() const {
	return 1.0;
}

double OrionConfig::sdrRefMax() const {
	return 109.0;
}

int32_t OrionConfig::getHdrPeak() const
{
    return m_HdrPeak;
}

void OrionConfig::setHdrPeak(int32_t value)
{
	int32_t v = value;
	int32_t min = hdrPeakMin();
	int32_t max = hdrPeakMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_HdrPeak = v;
    m_HdrPeakIsSet = true;
}

bool OrionConfig::hdrPeakIsSet() const
{
    return m_HdrPeakIsSet;
}

void OrionConfig::unsetHdrPeak()
{
    m_HdrPeakIsSet = false;
}

int32_t OrionConfig::hdrPeakMin() const {
	return 100;
}

int32_t OrionConfig::hdrPeakMax() const {
	return 4000;
}

std::shared_ptr<OrionSdrEotf> OrionConfig::getSdrEotf() const
{
    return m_SdrEotf;
}

void OrionConfig::setSdrEotf(const std::shared_ptr<OrionSdrEotf>& value)
{
	std::shared_ptr<OrionSdrEotf> v = value;
    m_SdrEotf = v;
    m_SdrEotfIsSet = true;
}

bool OrionConfig::sdrEotfIsSet() const
{
    return m_SdrEotfIsSet;
}

void OrionConfig::unsetSdrEotf()
{
    m_SdrEotfIsSet = false;
}


double OrionConfig::getPreKnee() const
{
    return m_PreKnee;
}

void OrionConfig::setPreKnee(double value)
{
	double v = value;
	double min = preKneeMin();
	double max = preKneeMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_PreKnee = v;
    m_PreKneeIsSet = true;
}

bool OrionConfig::preKneeIsSet() const
{
    return m_PreKneeIsSet;
}

void OrionConfig::unsetPreKnee()
{
    m_PreKneeIsSet = false;
}

double OrionConfig::preKneeMin() const {
	return 0.0;
}

double OrionConfig::preKneeMax() const {
	return 100.0;
}

double OrionConfig::getPreAmount() const
{
    return m_PreAmount;
}

void OrionConfig::setPreAmount(double value)
{
	double v = value;
	double min = preAmountMin();
	double max = preAmountMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_PreAmount = v;
    m_PreAmountIsSet = true;
}

bool OrionConfig::preAmountIsSet() const
{
    return m_PreAmountIsSet;
}

void OrionConfig::unsetPreAmount()
{
    m_PreAmountIsSet = false;
}

double OrionConfig::preAmountMin() const {
	return 0.0;
}

double OrionConfig::preAmountMax() const {
	return 1.0;
}

double OrionConfig::getPostKnee() const
{
    return m_PostKnee;
}

void OrionConfig::setPostKnee(double value)
{
	double v = value;
	double min = postKneeMin();
	double max = postKneeMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_PostKnee = v;
    m_PostKneeIsSet = true;
}

bool OrionConfig::postKneeIsSet() const
{
    return m_PostKneeIsSet;
}

void OrionConfig::unsetPostKnee()
{
    m_PostKneeIsSet = false;
}

double OrionConfig::postKneeMin() const {
	return 0.0;
}

double OrionConfig::postKneeMax() const {
	return 100.0;
}

double OrionConfig::getPostAmount() const
{
    return m_PostAmount;
}

void OrionConfig::setPostAmount(double value)
{
	double v = value;
	double min = postAmountMin();
	double max = postAmountMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_PostAmount = v;
    m_PostAmountIsSet = true;
}

bool OrionConfig::postAmountIsSet() const
{
    return m_PostAmountIsSet;
}

void OrionConfig::unsetPostAmount()
{
    m_PostAmountIsSet = false;
}

double OrionConfig::postAmountMin() const {
	return 0.0;
}

double OrionConfig::postAmountMax() const {
	return 1.0;
}

std::shared_ptr<OrionClamping> OrionConfig::getClamping() const
{
    return m_Clamping;
}

void OrionConfig::setClamping(const std::shared_ptr<OrionClamping>& value)
{
	std::shared_ptr<OrionClamping> v = value;
    m_Clamping = v;
    m_ClampingIsSet = true;
}

bool OrionConfig::clampingIsSet() const
{
    return m_ClampingIsSet;
}

void OrionConfig::unsetClamping()
{
    m_ClampingIsSet = false;
}


std::shared_ptr<OrionImplementation> OrionConfig::getImplementation() const
{
    return m_Implementation;
}

void OrionConfig::setImplementation(const std::shared_ptr<OrionImplementation>& value)
{
	std::shared_ptr<OrionImplementation> v = value;
    m_Implementation = v;
    m_ImplementationIsSet = true;
}

bool OrionConfig::implementationIsSet() const
{
    return m_ImplementationIsSet;
}

void OrionConfig::unsetImplementation()
{
    m_ImplementationIsSet = false;
}


}
}
}
}


