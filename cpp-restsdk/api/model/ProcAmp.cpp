/**
 * OpenAPI ColorBox
 * This is a REST API for the AJA ColorBox product.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@aja.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.4.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 * Copyright (C) 2020-2022 AJA Video Systems Inc.  All rights reserved.
 */



#include "ProcAmp.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




ProcAmp::ProcAmp()
{
    m_Black = 0.0;
    m_BlackIsSet = false;
    m_Gain = 0.0;
    m_GainIsSet = false;
    m_Hue = 0.0;
    m_HueIsSet = false;
    m_Sat = 0.0;
    m_SatIsSet = false;
    m_UnitsBlack = utility::conversions::to_string_t("");
    m_UnitsBlackIsSet = false;
    m_UnitsGain = utility::conversions::to_string_t("");
    m_UnitsGainIsSet = false;
    m_UnitsHue = utility::conversions::to_string_t("");
    m_UnitsHueIsSet = false;
    m_UnitsSat = utility::conversions::to_string_t("");
    m_UnitsSatIsSet = false;
}

ProcAmp::~ProcAmp()
{
}

void ProcAmp::validate()
{
    // TODO: implement validation
}

bool ProcAmp::applyMinMaxConstraints()
{
	bool anyMinMaxValueChanged = false;
	if (blackIsSet())
	{
		bool blackChanged = false;
		double v = getBlack();
		double min = blackMin();
		double max = blackMax();
		if (v < min) { v = min; blackChanged = true; }
		if (v > max) { v = max; blackChanged = true; }
		if (blackChanged) { setBlack(v); anyMinMaxValueChanged = true; }
	}
	if (gainIsSet())
	{
		bool gainChanged = false;
		double v = getGain();
		double min = gainMin();
		double max = gainMax();
		if (v < min) { v = min; gainChanged = true; }
		if (v > max) { v = max; gainChanged = true; }
		if (gainChanged) { setGain(v); anyMinMaxValueChanged = true; }
	}
	if (hueIsSet())
	{
		bool hueChanged = false;
		double v = getHue();
		double min = hueMin();
		double max = hueMax();
		if (v < min) { v = min; hueChanged = true; }
		if (v > max) { v = max; hueChanged = true; }
		if (hueChanged) { setHue(v); anyMinMaxValueChanged = true; }
	}
	if (satIsSet())
	{
		bool satChanged = false;
		double v = getSat();
		double min = satMin();
		double max = satMax();
		if (v < min) { v = min; satChanged = true; }
		if (v > max) { v = max; satChanged = true; }
		if (satChanged) { setSat(v); anyMinMaxValueChanged = true; }
	}
	if (unitsBlackIsSet())
	{
		bool unitsBlackChanged = false;
		utility::string_t v = getUnitsBlack();
		if (unitsBlackChanged) { setUnitsBlack(v); anyMinMaxValueChanged = true; }
	}
	if (unitsGainIsSet())
	{
		bool unitsGainChanged = false;
		utility::string_t v = getUnitsGain();
		if (unitsGainChanged) { setUnitsGain(v); anyMinMaxValueChanged = true; }
	}
	if (unitsHueIsSet())
	{
		bool unitsHueChanged = false;
		utility::string_t v = getUnitsHue();
		if (unitsHueChanged) { setUnitsHue(v); anyMinMaxValueChanged = true; }
	}
	if (unitsSatIsSet())
	{
		bool unitsSatChanged = false;
		utility::string_t v = getUnitsSat();
		if (unitsSatChanged) { setUnitsSat(v); anyMinMaxValueChanged = true; }
	}
	return anyMinMaxValueChanged;
}

web::json::value ProcAmp::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_BlackIsSet)
    {
        val[utility::conversions::to_string_t(U("black"))] = ModelBase::toJson(m_Black);
    }
    if(m_GainIsSet)
    {
        val[utility::conversions::to_string_t(U("gain"))] = ModelBase::toJson(m_Gain);
    }
    if(m_HueIsSet)
    {
        val[utility::conversions::to_string_t(U("hue"))] = ModelBase::toJson(m_Hue);
    }
    if(m_SatIsSet)
    {
        val[utility::conversions::to_string_t(U("sat"))] = ModelBase::toJson(m_Sat);
    }
    if(m_UnitsBlackIsSet)
    {
        val[utility::conversions::to_string_t(U("unitsBlack"))] = ModelBase::toJson(m_UnitsBlack);
    }
    if(m_UnitsGainIsSet)
    {
        val[utility::conversions::to_string_t(U("unitsGain"))] = ModelBase::toJson(m_UnitsGain);
    }
    if(m_UnitsHueIsSet)
    {
        val[utility::conversions::to_string_t(U("unitsHue"))] = ModelBase::toJson(m_UnitsHue);
    }
    if(m_UnitsSatIsSet)
    {
        val[utility::conversions::to_string_t(U("unitsSat"))] = ModelBase::toJson(m_UnitsSat);
    }

    return val;
}

bool ProcAmp::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("black"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("black")));
        if(!fieldValue.is_null())
        {
            double refVal_black;
            ok &= ModelBase::fromJson(fieldValue, refVal_black);
            setBlack(refVal_black);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("gain"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("gain")));
        if(!fieldValue.is_null())
        {
            double refVal_gain;
            ok &= ModelBase::fromJson(fieldValue, refVal_gain);
            setGain(refVal_gain);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("hue"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("hue")));
        if(!fieldValue.is_null())
        {
            double refVal_hue;
            ok &= ModelBase::fromJson(fieldValue, refVal_hue);
            setHue(refVal_hue);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sat"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sat")));
        if(!fieldValue.is_null())
        {
            double refVal_sat;
            ok &= ModelBase::fromJson(fieldValue, refVal_sat);
            setSat(refVal_sat);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unitsBlack"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unitsBlack")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_unitsBlack;
            ok &= ModelBase::fromJson(fieldValue, refVal_unitsBlack);
            setUnitsBlack(refVal_unitsBlack);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unitsGain"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unitsGain")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_unitsGain;
            ok &= ModelBase::fromJson(fieldValue, refVal_unitsGain);
            setUnitsGain(refVal_unitsGain);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unitsHue"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unitsHue")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_unitsHue;
            ok &= ModelBase::fromJson(fieldValue, refVal_unitsHue);
            setUnitsHue(refVal_unitsHue);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unitsSat"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unitsSat")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_unitsSat;
            ok &= ModelBase::fromJson(fieldValue, refVal_unitsSat);
            setUnitsSat(refVal_unitsSat);
        }
    }
    
    applyMinMaxConstraints();
    return ok;
}

void ProcAmp::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_BlackIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("black")), m_Black));
    }
    if(m_GainIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("gain")), m_Gain));
    }
    if(m_HueIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("hue")), m_Hue));
    }
    if(m_SatIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sat")), m_Sat));
    }
    if(m_UnitsBlackIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unitsBlack")), m_UnitsBlack));
    }
    if(m_UnitsGainIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unitsGain")), m_UnitsGain));
    }
    if(m_UnitsHueIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unitsHue")), m_UnitsHue));
    }
    if(m_UnitsSatIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unitsSat")), m_UnitsSat));
    }
}

bool ProcAmp::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("black"))))
    {
        double refVal_black;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("black"))), refVal_black );
        setBlack(refVal_black);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("gain"))))
    {
        double refVal_gain;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("gain"))), refVal_gain );
        setGain(refVal_gain);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("hue"))))
    {
        double refVal_hue;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("hue"))), refVal_hue );
        setHue(refVal_hue);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sat"))))
    {
        double refVal_sat;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sat"))), refVal_sat );
        setSat(refVal_sat);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unitsBlack"))))
    {
        utility::string_t refVal_unitsBlack;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unitsBlack"))), refVal_unitsBlack );
        setUnitsBlack(refVal_unitsBlack);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unitsGain"))))
    {
        utility::string_t refVal_unitsGain;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unitsGain"))), refVal_unitsGain );
        setUnitsGain(refVal_unitsGain);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unitsHue"))))
    {
        utility::string_t refVal_unitsHue;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unitsHue"))), refVal_unitsHue );
        setUnitsHue(refVal_unitsHue);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unitsSat"))))
    {
        utility::string_t refVal_unitsSat;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unitsSat"))), refVal_unitsSat );
        setUnitsSat(refVal_unitsSat);
    }
    
    applyMinMaxConstraints();
    return ok;
}

double ProcAmp::getBlack() const
{
    return m_Black;
}

void ProcAmp::setBlack(double value)
{
	double v = value;
	double min = blackMin();
	double max = blackMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_Black = v;
    m_BlackIsSet = true;
}

bool ProcAmp::blackIsSet() const
{
    return m_BlackIsSet;
}

void ProcAmp::unsetBlack()
{
    m_BlackIsSet = false;
}

double ProcAmp::blackMin() const {
	return -20.0;
}

double ProcAmp::blackMax() const {
	return 20.0;
}

double ProcAmp::getGain() const
{
    return m_Gain;
}

void ProcAmp::setGain(double value)
{
	double v = value;
	double min = gainMin();
	double max = gainMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_Gain = v;
    m_GainIsSet = true;
}

bool ProcAmp::gainIsSet() const
{
    return m_GainIsSet;
}

void ProcAmp::unsetGain()
{
    m_GainIsSet = false;
}

double ProcAmp::gainMin() const {
	return 0;
}

double ProcAmp::gainMax() const {
	return 1.5;
}

double ProcAmp::getHue() const
{
    return m_Hue;
}

void ProcAmp::setHue(double value)
{
	double v = value;
	double min = hueMin();
	double max = hueMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_Hue = v;
    m_HueIsSet = true;
}

bool ProcAmp::hueIsSet() const
{
    return m_HueIsSet;
}

void ProcAmp::unsetHue()
{
    m_HueIsSet = false;
}

double ProcAmp::hueMin() const {
	return -179;
}

double ProcAmp::hueMax() const {
	return 180;
}

double ProcAmp::getSat() const
{
    return m_Sat;
}

void ProcAmp::setSat(double value)
{
	double v = value;
	double min = satMin();
	double max = satMax();
	if (v < min) { v = min; }
	if (v > max) { v = max; }
    m_Sat = v;
    m_SatIsSet = true;
}

bool ProcAmp::satIsSet() const
{
    return m_SatIsSet;
}

void ProcAmp::unsetSat()
{
    m_SatIsSet = false;
}

double ProcAmp::satMin() const {
	return 0.0;
}

double ProcAmp::satMax() const {
	return 1.5;
}

utility::string_t ProcAmp::getUnitsBlack() const
{
    return m_UnitsBlack;
}

void ProcAmp::setUnitsBlack(const utility::string_t& value)
{
	utility::string_t v = value;
    m_UnitsBlack = v;
    m_UnitsBlackIsSet = true;
}

bool ProcAmp::unitsBlackIsSet() const
{
    return m_UnitsBlackIsSet;
}

void ProcAmp::unsetUnitsBlack()
{
    m_UnitsBlackIsSet = false;
}



utility::string_t ProcAmp::getUnitsGain() const
{
    return m_UnitsGain;
}

void ProcAmp::setUnitsGain(const utility::string_t& value)
{
	utility::string_t v = value;
    m_UnitsGain = v;
    m_UnitsGainIsSet = true;
}

bool ProcAmp::unitsGainIsSet() const
{
    return m_UnitsGainIsSet;
}

void ProcAmp::unsetUnitsGain()
{
    m_UnitsGainIsSet = false;
}



utility::string_t ProcAmp::getUnitsHue() const
{
    return m_UnitsHue;
}

void ProcAmp::setUnitsHue(const utility::string_t& value)
{
	utility::string_t v = value;
    m_UnitsHue = v;
    m_UnitsHueIsSet = true;
}

bool ProcAmp::unitsHueIsSet() const
{
    return m_UnitsHueIsSet;
}

void ProcAmp::unsetUnitsHue()
{
    m_UnitsHueIsSet = false;
}



utility::string_t ProcAmp::getUnitsSat() const
{
    return m_UnitsSat;
}

void ProcAmp::setUnitsSat(const utility::string_t& value)
{
	utility::string_t v = value;
    m_UnitsSat = v;
    m_UnitsSatIsSet = true;
}

bool ProcAmp::unitsSatIsSet() const
{
    return m_UnitsSatIsSet;
}

void ProcAmp::unsetUnitsSat()
{
    m_UnitsSatIsSet = false;
}



}
}
}
}


